{"version":3,"file":"index.umd.min.js","sources":["../src/class/Registry.js","../src/class/OptionRegistry.js","../src/api/option.js","../src/core/constants.js","../node_modules/ret/lib/types.js","../node_modules/ret/lib/sets.js","../node_modules/ret/lib/util.js","../node_modules/ret/lib/positions.js","../node_modules/ret/lib/index.js","../node_modules/drange/lib/index.js","../node_modules/randexp/lib/randexp.js","../src/core/random.js","../src/core/utils.js","../src/class/Container.js","../src/api/format.js","../src/core/error.js","../src/core/infer.js","../src/types/boolean.js","../src/generators/boolean.js","../src/types/null.js","../src/generators/null.js","../src/types/number.js","../src/generators/words.js","../src/types/object.js","../src/generators/thunk.js","../src/generators/dateTime.js","../src/generators/coreFormat.js","../src/types/string.js","../src/generators/date.js","../src/generators/time.js","../src/generators/ipv4.js","../src/types/index.js","../src/types/array.js","../src/types/integer.js","../src/core/traverse.js","../src/core/run.js","../src/index.js"],"sourcesContent":["/**\n * This class defines a registry for custom formats used within JSF.\n */\nclass Registry {\n  constructor() {\n    // empty by default\n    this.data = {};\n  }\n\n  /**\n   * Unregisters custom format(s)\n   * @param name\n   */\n  unregister(name) {\n    if (!name) {\n      this.data = {};\n    } else {\n      delete this.data[name];\n    }\n  }\n\n  /**\n   * Registers custom format\n   */\n  register(name, callback) {\n    this.data[name] = callback;\n  }\n\n  /**\n   * Register many formats at one shot\n   */\n  registerMany(formats) {\n    Object.keys(formats).forEach(name => {\n      this.data[name] = formats[name];\n    });\n  }\n\n  /**\n   * Returns element by registry key\n   */\n  get(name) {\n    const format = this.data[name];\n\n    return format;\n  }\n\n  /**\n   * Returns the whole registry content\n   */\n  list() {\n    return this.data;\n  }\n}\n\nexport default Registry;\n","import Registry from './Registry';\n\nconst defaults = {};\n\ndefaults.defaultInvalidTypeProduct = null;\ndefaults.defaultRandExpMax = 10;\n\ndefaults.ignoreProperties = [];\ndefaults.ignoreMissingRefs = false;\ndefaults.failOnInvalidTypes = true;\ndefaults.failOnInvalidFormat = true;\n\ndefaults.alwaysFakeOptionals = false;\ndefaults.optionalsProbability = false;\ndefaults.fixedProbabilities = false;\ndefaults.useExamplesValue = false;\ndefaults.useDefaultValue = false;\ndefaults.requiredOnly = false;\n\ndefaults.minItems = 0;\ndefaults.maxItems = null;\ndefaults.minLength = 0;\ndefaults.maxLength = null;\n\ndefaults.resolveJsonPath = false;\ndefaults.reuseProperties = false;\ndefaults.fillProperties = true;\n\ndefaults.random = Math.random;\n\n/**\n * This class defines a registry for custom settings used within JSF.\n */\nclass OptionRegistry extends Registry {\n  constructor() {\n    super();\n    this.data = { ...defaults };\n    this._defaults = defaults;\n  }\n\n  get defaults() {\n    return { ...this._defaults };\n  }\n}\n\nexport default OptionRegistry;\n","import OptionRegistry from '../class/OptionRegistry';\n\n// instantiate\nconst registry = new OptionRegistry();\n\n/**\n * Custom option API\n *\n * @param nameOrOptionMap\n * @returns {any}\n */\nfunction optionAPI(nameOrOptionMap, optionalValue) {\n  if (typeof nameOrOptionMap === 'string') {\n    if (typeof optionalValue !== 'undefined') {\n      return registry.register(nameOrOptionMap, optionalValue);\n    }\n\n    return registry.get(nameOrOptionMap);\n  }\n\n  return registry.registerMany(nameOrOptionMap);\n}\n\noptionAPI.getDefaults = () => registry.defaults;\n\nexport default optionAPI;\n","const ALL_TYPES = ['array', 'object', 'integer', 'number', 'string', 'boolean', 'null'];\n\nconst MOST_NEAR_DATETIME = 2524608000000;\n\nconst MIN_INTEGER = -100000000;\nconst MAX_INTEGER = 100000000;\n\nconst MIN_NUMBER = -100;\nconst MAX_NUMBER = 100;\n\nexport default {\n  ALL_TYPES,\n  MIN_NUMBER,\n  MAX_NUMBER,\n  MIN_INTEGER,\n  MAX_INTEGER,\n  MOST_NEAR_DATETIME,\n};\n","module.exports = {\n  ROOT       : 0,\n  GROUP      : 1,\n  POSITION   : 2,\n  SET        : 3,\n  RANGE      : 4,\n  REPETITION : 5,\n  REFERENCE  : 6,\n  CHAR       : 7,\n};\n","const types = require('./types');\n\nconst INTS = () => [{ type: types.RANGE , from: 48, to: 57 }];\n\nconst WORDS = () => {\n  return [\n    { type: types.CHAR, value: 95 },\n    { type: types.RANGE, from: 97, to: 122 },\n    { type: types.RANGE, from: 65, to: 90 }\n  ].concat(INTS());\n};\n\nconst WHITESPACE = () => {\n  return [\n    { type: types.CHAR, value: 9 },\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 11 },\n    { type: types.CHAR, value: 12 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 32 },\n    { type: types.CHAR, value: 160 },\n    { type: types.CHAR, value: 5760 },\n    { type: types.RANGE, from: 8192, to: 8202 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n    { type: types.CHAR, value: 8239 },\n    { type: types.CHAR, value: 8287 },\n    { type: types.CHAR, value: 12288 },\n    { type: types.CHAR, value: 65279 }\n  ];\n};\n\nconst NOTANYCHAR = () => {\n  return [\n    { type: types.CHAR, value: 10 },\n    { type: types.CHAR, value: 13 },\n    { type: types.CHAR, value: 8232 },\n    { type: types.CHAR, value: 8233 },\n  ];\n};\n\n// Predefined class objects.\nexports.words = () => ({ type: types.SET, set: WORDS(), not: false });\nexports.notWords = () => ({ type: types.SET, set: WORDS(), not: true });\nexports.ints = () => ({ type: types.SET, set: INTS(), not: false });\nexports.notInts = () => ({ type: types.SET, set: INTS(), not: true });\nexports.whitespace = () => ({ type: types.SET, set: WHITESPACE(), not: false });\nexports.notWhitespace = () => ({ type: types.SET, set: WHITESPACE(), not: true });\nexports.anyChar = () => ({ type: types.SET, set: NOTANYCHAR(), not: true });\n","const types = require('./types');\nconst sets  = require('./sets');\n\n\nconst CTRL = '@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^ ?';\nconst SLSH = { '0': 0, 't': 9, 'n': 10, 'v': 11, 'f': 12, 'r': 13 };\n\n/**\n * Finds character representations in str and convert all to\n * their respective characters\n *\n * @param {String} str\n * @return {String}\n */\nexports.strToChars = function(str) {\n  /* jshint maxlen: false */\n  var chars_regex = /(\\[\\\\b\\])|(\\\\)?\\\\(?:u([A-F0-9]{4})|x([A-F0-9]{2})|(0?[0-7]{2})|c([@A-Z[\\\\\\]^?])|([0tnvfr]))/g;\n  str = str.replace(chars_regex, function(s, b, lbs, a16, b16, c8, dctrl, eslsh) {\n    if (lbs) {\n      return s;\n    }\n\n    var code = b ? 8 :\n      a16   ? parseInt(a16, 16) :\n      b16   ? parseInt(b16, 16) :\n      c8    ? parseInt(c8,   8) :\n      dctrl ? CTRL.indexOf(dctrl) :\n      SLSH[eslsh];\n\n    var c = String.fromCharCode(code);\n\n    // Escape special regex characters.\n    if (/[[\\]{}^$.|?*+()]/.test(c)) {\n      c = '\\\\' + c;\n    }\n\n    return c;\n  });\n\n  return str;\n};\n\n\n/**\n * turns class into tokens\n * reads str until it encounters a ] not preceeded by a \\\n *\n * @param {String} str\n * @param {String} regexpStr\n * @return {Array.<Array.<Object>, Number>}\n */\nexports.tokenizeClass = (str, regexpStr) => {\n  /* jshint maxlen: false */\n  var tokens = [];\n  var regexp = /\\\\(?:(w)|(d)|(s)|(W)|(D)|(S))|((?:(?:\\\\)(.)|([^\\]\\\\]))-(?:\\\\)?([^\\]]))|(\\])|(?:\\\\)?([^])/g;\n  var rs, c;\n\n\n  while ((rs = regexp.exec(str)) != null) {\n    if (rs[1]) {\n      tokens.push(sets.words());\n\n    } else if (rs[2]) {\n      tokens.push(sets.ints());\n\n    } else if (rs[3]) {\n      tokens.push(sets.whitespace());\n\n    } else if (rs[4]) {\n      tokens.push(sets.notWords());\n\n    } else if (rs[5]) {\n      tokens.push(sets.notInts());\n\n    } else if (rs[6]) {\n      tokens.push(sets.notWhitespace());\n\n    } else if (rs[7]) {\n      tokens.push({\n        type: types.RANGE,\n        from: (rs[8] || rs[9]).charCodeAt(0),\n        to: rs[10].charCodeAt(0),\n      });\n\n    } else if ((c = rs[12])) {\n      tokens.push({\n        type: types.CHAR,\n        value: c.charCodeAt(0),\n      });\n\n    } else {\n      return [tokens, regexp.lastIndex];\n    }\n  }\n\n  exports.error(regexpStr, 'Unterminated character class');\n};\n\n\n/**\n * Shortcut to throw errors.\n *\n * @param {String} regexp\n * @param {String} msg\n */\nexports.error = (regexp, msg) => {\n  throw new SyntaxError('Invalid regular expression: /' + regexp + '/: ' + msg);\n};\n","const types = require('./types');\nexports.wordBoundary = () => ({ type: types.POSITION, value: 'b' });\nexports.nonWordBoundary = () => ({ type: types.POSITION, value: 'B' });\nexports.begin = () => ({ type: types.POSITION, value: '^' });\nexports.end = () => ({ type: types.POSITION, value: '$' });\n","const util      = require('./util');\nconst types     = require('./types');\nconst sets      = require('./sets');\nconst positions = require('./positions');\n\n\nmodule.exports = (regexpStr) => {\n  var i = 0, l, c,\n    start = { type: types.ROOT, stack: []},\n\n    // Keep track of last clause/group and stack.\n    lastGroup = start,\n    last = start.stack,\n    groupStack = [];\n\n\n  var repeatErr = (i) => {\n    util.error(regexpStr, `Nothing to repeat at column ${i - 1}`);\n  };\n\n  // Decode a few escaped characters.\n  var str = util.strToChars(regexpStr);\n  l = str.length;\n\n  // Iterate through each character in string.\n  while (i < l) {\n    c = str[i++];\n\n    switch (c) {\n      // Handle escaped characters, inclues a few sets.\n      case '\\\\':\n        c = str[i++];\n\n        switch (c) {\n          case 'b':\n            last.push(positions.wordBoundary());\n            break;\n\n          case 'B':\n            last.push(positions.nonWordBoundary());\n            break;\n\n          case 'w':\n            last.push(sets.words());\n            break;\n\n          case 'W':\n            last.push(sets.notWords());\n            break;\n\n          case 'd':\n            last.push(sets.ints());\n            break;\n\n          case 'D':\n            last.push(sets.notInts());\n            break;\n\n          case 's':\n            last.push(sets.whitespace());\n            break;\n\n          case 'S':\n            last.push(sets.notWhitespace());\n            break;\n\n          default:\n            // Check if c is integer.\n            // In which case it's a reference.\n            if (/\\d/.test(c)) {\n              last.push({ type: types.REFERENCE, value: parseInt(c, 10) });\n\n            // Escaped character.\n            } else {\n              last.push({ type: types.CHAR, value: c.charCodeAt(0) });\n            }\n        }\n\n        break;\n\n\n      // Positionals.\n      case '^':\n        last.push(positions.begin());\n        break;\n\n      case '$':\n        last.push(positions.end());\n        break;\n\n\n      // Handle custom sets.\n      case '[':\n        // Check if this class is 'anti' i.e. [^abc].\n        var not;\n        if (str[i] === '^') {\n          not = true;\n          i++;\n        } else {\n          not = false;\n        }\n\n        // Get all the characters in class.\n        var classTokens = util.tokenizeClass(str.slice(i), regexpStr);\n\n        // Increase index by length of class.\n        i += classTokens[1];\n        last.push({\n          type: types.SET,\n          set: classTokens[0],\n          not,\n        });\n\n        break;\n\n\n      // Class of any character except \\n.\n      case '.':\n        last.push(sets.anyChar());\n        break;\n\n\n      // Push group onto stack.\n      case '(':\n        // Create group.\n        var group = {\n          type: types.GROUP,\n          stack: [],\n          remember: true,\n        };\n\n        c = str[i];\n\n        // If if this is a special kind of group.\n        if (c === '?') {\n          c = str[i + 1];\n          i += 2;\n\n          // Match if followed by.\n          if (c === '=') {\n            group.followedBy = true;\n\n          // Match if not followed by.\n          } else if (c === '!') {\n            group.notFollowedBy = true;\n\n          } else if (c !== ':') {\n            util.error(regexpStr,\n              `Invalid group, character '${c}'` +\n              ` after '?' at column ${i - 1}`);\n          }\n\n          group.remember = false;\n        }\n\n        // Insert subgroup into current group stack.\n        last.push(group);\n\n        // Remember the current group for when the group closes.\n        groupStack.push(lastGroup);\n\n        // Make this new group the current group.\n        lastGroup = group;\n        last = group.stack;\n        break;\n\n\n      // Pop group out of stack.\n      case ')':\n        if (groupStack.length === 0) {\n          util.error(regexpStr, `Unmatched ) at column ${i - 1}`);\n        }\n        lastGroup = groupStack.pop();\n\n        // Check if this group has a PIPE.\n        // To get back the correct last stack.\n        last = lastGroup.options ?\n          lastGroup.options[lastGroup.options.length - 1] : lastGroup.stack;\n        break;\n\n\n      // Use pipe character to give more choices.\n      case '|':\n        // Create array where options are if this is the first PIPE\n        // in this clause.\n        if (!lastGroup.options) {\n          lastGroup.options = [lastGroup.stack];\n          delete lastGroup.stack;\n        }\n\n        // Create a new stack and add to options for rest of clause.\n        var stack = [];\n        lastGroup.options.push(stack);\n        last = stack;\n        break;\n\n\n      // Repetition.\n      // For every repetition, remove last element from last stack\n      // then insert back a RANGE object.\n      // This design is chosen because there could be more than\n      // one repetition symbols in a regex i.e. `a?+{2,3}`.\n      case '{':\n        var rs = /^(\\d+)(,(\\d+)?)?\\}/.exec(str.slice(i)), min, max;\n        if (rs !== null) {\n          if (last.length === 0) {\n            repeatErr(i);\n          }\n          min = parseInt(rs[1], 10);\n          max = rs[2] ? rs[3] ? parseInt(rs[3], 10) : Infinity : min;\n          i += rs[0].length;\n\n          last.push({\n            type: types.REPETITION,\n            min,\n            max,\n            value: last.pop(),\n          });\n        } else {\n          last.push({\n            type: types.CHAR,\n            value: 123,\n          });\n        }\n        break;\n\n      case '?':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: 1,\n          value: last.pop(),\n        });\n        break;\n\n      case '+':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 1,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n      case '*':\n        if (last.length === 0) {\n          repeatErr(i);\n        }\n        last.push({\n          type: types.REPETITION,\n          min: 0,\n          max: Infinity,\n          value: last.pop(),\n        });\n        break;\n\n\n      // Default is a character that is not `\\[](){}?+*^$`.\n      default:\n        last.push({\n          type: types.CHAR,\n          value: c.charCodeAt(0),\n        });\n    }\n\n  }\n\n  // Check if any groups have not been closed.\n  if (groupStack.length !== 0) {\n    util.error(regexpStr, 'Unterminated group');\n  }\n\n  return start;\n};\n\nmodule.exports.types = types;\n","'use strict';\n/* eslint indent: 4 */\n\n\n// Private helper class\nclass SubRange {\n    constructor(low, high) {\n        this.low = low;\n        this.high = high;\n        this.length = 1 + high - low;\n    }\n\n    overlaps(range) {\n        return !(this.high < range.low || this.low > range.high);\n    }\n\n    touches(range) {\n        return !(this.high + 1 < range.low || this.low - 1 > range.high);\n    }\n\n    // Returns inclusive combination of SubRanges as a SubRange.\n    add(range) {\n        return new SubRange(\n            Math.min(this.low, range.low),\n            Math.max(this.high, range.high)\n        );\n    }\n\n    // Returns subtraction of SubRanges as an array of SubRanges.\n    // (There's a case where subtraction divides it in 2)\n    subtract(range) {\n        if (range.low <= this.low && range.high >= this.high) {\n            return [];\n        } else if (range.low > this.low && range.high < this.high) {\n            return [\n                new SubRange(this.low, range.low - 1),\n                new SubRange(range.high + 1, this.high)\n            ];\n        } else if (range.low <= this.low) {\n            return [new SubRange(range.high + 1, this.high)];\n        } else {\n            return [new SubRange(this.low, range.low - 1)];\n        }\n    }\n\n    toString() {\n        return this.low == this.high ?\n            this.low.toString() : this.low + '-' + this.high;\n    }\n}\n\n\nclass DRange {\n    constructor(a, b) {\n        this.ranges = [];\n        this.length = 0;\n        if (a != null) this.add(a, b);\n    }\n\n    _update_length() {\n        this.length = this.ranges.reduce((previous, range) => {\n            return previous + range.length;\n        }, 0);\n    }\n\n    add(a, b) {\n        var _add = (subrange) => {\n            var i = 0;\n            while (i < this.ranges.length && !subrange.touches(this.ranges[i])) {\n                i++;\n            }\n            var newRanges = this.ranges.slice(0, i);\n            while (i < this.ranges.length && subrange.touches(this.ranges[i])) {\n                subrange = subrange.add(this.ranges[i]);\n                i++;\n            }\n            newRanges.push(subrange);\n            this.ranges = newRanges.concat(this.ranges.slice(i));\n            this._update_length();\n        }\n\n        if (a instanceof DRange) {\n            a.ranges.forEach(_add);\n        } else {\n            if (b == null) b = a;\n            _add(new SubRange(a, b));\n        }\n        return this;\n    }\n\n    subtract(a, b) {\n        var _subtract = (subrange) => {\n            var i = 0;\n            while (i < this.ranges.length && !subrange.overlaps(this.ranges[i])) {\n                i++;\n            }\n            var newRanges = this.ranges.slice(0, i);\n            while (i < this.ranges.length && subrange.overlaps(this.ranges[i])) {\n                newRanges = newRanges.concat(this.ranges[i].subtract(subrange));\n                i++;\n            }\n            this.ranges = newRanges.concat(this.ranges.slice(i));\n            this._update_length();\n        };\n\n        if (a instanceof DRange) {\n            a.ranges.forEach(_subtract);\n        } else {\n            if (b == null) b = a;\n            _subtract(new SubRange(a, b));\n        }\n        return this;\n    }\n\n    intersect(a, b) {\n        var newRanges = [];\n        var _intersect = (subrange) => {\n            var i = 0;\n            while (i < this.ranges.length && !subrange.overlaps(this.ranges[i])) {\n                i++;\n            }\n            while (i < this.ranges.length && subrange.overlaps(this.ranges[i])) {\n                var low = Math.max(this.ranges[i].low, subrange.low);\n                var high = Math.min(this.ranges[i].high, subrange.high);\n                newRanges.push(new SubRange(low, high));\n                i++;\n            }\n        };\n\n        if (a instanceof DRange) {\n            a.ranges.forEach(_intersect);\n        } else {\n            if (b == null) b = a;\n            _intersect(new SubRange(a, b));\n        }\n        this.ranges = newRanges;\n        this._update_length();\n        return this;\n    }\n\n    index(index) {\n        var i = 0;\n        while (i < this.ranges.length && this.ranges[i].length <= index) {\n            index -= this.ranges[i].length;\n            i++;\n        }\n        return this.ranges[i].low + index;\n    }\n\n    toString() {\n        return '[ ' + this.ranges.join(', ') + ' ]';\n    }\n\n    clone() {\n        return new DRange(this);\n    }\n}\n\nmodule.exports = DRange;\n","const ret    = require('ret');\nconst DRange = require('drange');\nconst types  = ret.types;\n\n\nmodule.exports = class RandExp {\n  /**\n   * @constructor\n   * @param {RegExp|String} regexp\n   * @param {String} m\n   */\n  constructor(regexp, m) {\n    this._setDefaults(regexp);\n    if (regexp instanceof RegExp) {\n      this.ignoreCase = regexp.ignoreCase;\n      this.multiline = regexp.multiline;\n      regexp = regexp.source;\n\n    } else if (typeof regexp === 'string') {\n      this.ignoreCase = m && m.indexOf('i') !== -1;\n      this.multiline = m && m.indexOf('m') !== -1;\n    } else {\n      throw new Error('Expected a regexp or string');\n    }\n\n    this.tokens = ret(regexp);\n  }\n\n\n  /**\n   * Checks if some custom properties have been set for this regexp.\n   *\n   * @param {RandExp} randexp\n   * @param {RegExp} regexp\n   */\n  _setDefaults(regexp) {\n    // When a repetitional token has its max set to Infinite,\n    // randexp won't actually generate a random amount between min and Infinite\n    // instead it will see Infinite as min + 100.\n    this.max = regexp.max != null ? regexp.max :\n      RandExp.prototype.max != null ? RandExp.prototype.max : 100;\n\n    // This allows expanding to include additional characters\n    // for instance: RandExp.defaultRange.add(0, 65535);\n    this.defaultRange = regexp.defaultRange ?\n      regexp.defaultRange : this.defaultRange.clone();\n\n    if (regexp.randInt) {\n      this.randInt = regexp.randInt;\n    }\n  }\n\n\n  /**\n   * Generates the random string.\n   *\n   * @return {String}\n   */\n  gen() {\n    return this._gen(this.tokens, []);\n  }\n\n\n  /**\n   * Generate random string modeled after given tokens.\n   *\n   * @param {Object} token\n   * @param {Array.<String>} groups\n   * @return {String}\n   */\n  _gen(token, groups) {\n    var stack, str, n, i, l;\n\n    switch (token.type) {\n      case types.ROOT:\n      case types.GROUP:\n        // Ignore lookaheads for now.\n        if (token.followedBy || token.notFollowedBy) { return ''; }\n\n        // Insert placeholder until group string is generated.\n        if (token.remember && token.groupNumber === undefined) {\n          token.groupNumber = groups.push(null) - 1;\n        }\n\n        stack = token.options ?\n          this._randSelect(token.options) : token.stack;\n\n        str = '';\n        for (i = 0, l = stack.length; i < l; i++) {\n          str += this._gen(stack[i], groups);\n        }\n\n        if (token.remember) {\n          groups[token.groupNumber] = str;\n        }\n        return str;\n\n      case types.POSITION:\n        // Do nothing for now.\n        return '';\n\n      case types.SET:\n        var expandedSet = this._expand(token);\n        if (!expandedSet.length) { return ''; }\n        return String.fromCharCode(this._randSelect(expandedSet));\n\n      case types.REPETITION:\n        // Randomly generate number between min and max.\n        n = this.randInt(token.min,\n          token.max === Infinity ? token.min + this.max : token.max);\n\n        str = '';\n        for (i = 0; i < n; i++) {\n          str += this._gen(token.value, groups);\n        }\n\n        return str;\n\n      case types.REFERENCE:\n        return groups[token.value - 1] || '';\n\n      case types.CHAR:\n        var code = this.ignoreCase && this._randBool() ?\n          this._toOtherCase(token.value) : token.value;\n        return String.fromCharCode(code);\n    }\n  }\n\n\n  /**\n   * If code is alphabetic, converts to other case.\n   * If not alphabetic, returns back code.\n   *\n   * @param {Number} code\n   * @return {Number}\n   */\n  _toOtherCase(code) {\n    return code + (97 <= code && code <= 122 ? -32 :\n      65 <= code && code <= 90  ?  32 : 0);\n  }\n\n\n  /**\n   * Randomly returns a true or false value.\n   *\n   * @return {Boolean}\n   */\n  _randBool() {\n    return !this.randInt(0, 1);\n  }\n\n\n  /**\n   * Randomly selects and returns a value from the array.\n   *\n   * @param {Array.<Object>} arr\n   * @return {Object}\n   */\n  _randSelect(arr) {\n    if (arr instanceof DRange) {\n      return arr.index(this.randInt(0, arr.length - 1));\n    }\n    return arr[this.randInt(0, arr.length - 1)];\n  }\n\n\n  /**\n   * expands a token to a DiscontinuousRange of characters which has a\n   * length and an index function (for random selecting)\n   *\n   * @param {Object} token\n   * @return {DiscontinuousRange}\n   */\n  _expand(token) {\n    if (token.type === ret.types.CHAR) {\n      return new DRange(token.value);\n    } else if (token.type === ret.types.RANGE) {\n      return new DRange(token.from, token.to);\n    } else {\n      let drange = new DRange();\n      for (let i = 0; i < token.set.length; i++) {\n        let subrange = this._expand(token.set[i]);\n        drange.add(subrange);\n        if (this.ignoreCase) {\n          for (let j = 0; j < subrange.length; j++) {\n            let code = subrange.index(j);\n            let otherCaseCode = this._toOtherCase(code);\n            if (code !== otherCaseCode) {\n              drange.add(otherCaseCode);\n            }\n          }\n        }\n      }\n      if (token.not) {\n        return this.defaultRange.clone().subtract(drange);\n      } else {\n        return this.defaultRange.clone().intersect(drange);\n      }\n    }\n  }\n\n\n  /**\n   * Randomly generates and returns a number between a and b (inclusive).\n   *\n   * @param {Number} a\n   * @param {Number} b\n   * @return {Number}\n   */\n  randInt(a, b) {\n    return a + Math.floor(Math.random() * (1 + b - a));\n  }\n\n\n  /**\n   * Default range of characters to generate from.\n   */\n  get defaultRange() {\n    return this._range = this._range || new DRange(32, 126);\n  }\n\n  set defaultRange(range) {\n    this._range = range;\n  }\n\n\n  /**\n   *\n   * Enables use of randexp with a shorter call.\n   *\n   * @param {RegExp|String| regexp}\n   * @param {String} m\n   * @return {String}\n   */\n  static randexp(regexp, m) {\n    var randexp;\n    if(typeof regexp === 'string') {\n      regexp = new RegExp(regexp, m);\n    }\n\n    if (regexp._randexp === undefined) {\n      randexp = new RandExp(regexp, m);\n      regexp._randexp = randexp;\n    } else {\n      randexp = regexp._randexp;\n      randexp._setDefaults(regexp);\n    }\n    return randexp.gen();\n  }\n\n\n  /**\n   * Enables sugary /regexp/.gen syntax.\n   */\n  static sugar() {\n    /* eshint freeze:false */\n    RegExp.prototype.gen = function() {\n      return RandExp.randexp(this);\n    };\n  }\n};\n","import RandExp from 'randexp';\n\nimport optionAPI from '../api/option';\nimport env from './constants';\n\nfunction getRandomInteger(min, max) {\n  min = typeof min === 'undefined' ? env.MIN_INTEGER : min;\n  max = typeof max === 'undefined' ? env.MAX_INTEGER : max;\n\n  return Math.floor(optionAPI('random')() * ((max - min) + 1)) + min;\n}\n\nfunction _randexp(value) {\n  // set maximum default, see #193\n  RandExp.prototype.max = optionAPI('defaultRandExpMax');\n\n  // same implementation as the original except using our random\n  RandExp.prototype.randInt = (a, b) => a + Math.floor(optionAPI('random')() * (1 + (b - a)));\n\n  const re = new RandExp(value);\n\n  return re.gen();\n}\n\n/**\n * Returns random element of a collection\n *\n * @param collection\n * @returns {T}\n */\nfunction pick(collection) {\n  return collection[Math.floor(optionAPI('random')() * collection.length)];\n}\n\n/**\n * Returns shuffled collection of elements\n *\n * @param collection\n * @returns {T[]}\n */\nfunction shuffle(collection) {\n  let tmp;\n  let key;\n  let length = collection.length;\n\n  const copy = collection.slice();\n\n  for (; length > 0;) {\n    key = Math.floor(optionAPI('random')() * length);\n    // swap\n    length -= 1;\n    tmp = copy[length];\n    copy[length] = copy[key];\n    copy[key] = tmp;\n  }\n\n  return copy;\n}\n\n\n/**\n * Returns a random integer between min (inclusive) and max (inclusive)\n * Using Math.round() will give you a non-uniform distribution!\n * @see http://stackoverflow.com/a/1527820/769384\n */\nfunction getRandom(min, max) {\n  return (optionAPI('random')() * (max - min)) + min;\n}\n\n/**\n * Generates random number according to parameters passed\n *\n * @param min\n * @param max\n * @param defMin\n * @param defMax\n * @param hasPrecision\n * @returns {number}\n */\nfunction number(min, max, defMin, defMax, hasPrecision = false) {\n  defMin = typeof defMin === 'undefined' ? env.MIN_NUMBER : defMin;\n  defMax = typeof defMax === 'undefined' ? env.MAX_NUMBER : defMax;\n\n  min = typeof min === 'undefined' ? defMin : min;\n  max = typeof max === 'undefined' ? defMax : max;\n\n  if (max < min) {\n    max += min;\n  }\n\n  if (hasPrecision) {\n    return getRandom(min, max);\n  }\n\n  return getRandomInteger(min, max);\n}\n\nfunction by(type) {\n  switch (type) {\n    case 'seconds':\n      return number(0, 60) * 60;\n\n    case 'minutes':\n      return number(15, 50) * 612;\n\n    case 'hours':\n      return number(12, 72) * 36123;\n\n    case 'days':\n      return number(7, 30) * 86412345;\n\n    case 'weeks':\n      return number(4, 52) * 604812345;\n\n    case 'months':\n      return number(2, 13) * 2592012345;\n\n    case 'years':\n      return number(1, 20) * 31104012345;\n\n    default: break;\n  }\n}\n\nfunction date(step) {\n  if (step) {\n    return by(step);\n  }\n\n  const now = new Date();\n  const days = number(-1000, env.MOST_NEAR_DATETIME);\n\n  now.setTime(now.getTime() - days);\n\n  return now;\n}\n\nexport default {\n  pick,\n  date,\n  shuffle,\n  number,\n  randexp: _randexp,\n};\n","import optionAPI from '../api/option';\nimport env from './constants';\nimport random from './random';\n\nfunction getSubAttribute(obj, dotSeparatedKey) {\n  const keyElements = dotSeparatedKey.split('.');\n\n  while (keyElements.length) {\n    const prop = keyElements.shift();\n\n    if (!obj[prop]) {\n      break;\n    }\n\n    obj = obj[prop];\n  }\n  return obj;\n}\n\n/**\n * Returns true/false whether the object parameter has its own properties defined\n *\n * @param obj\n * @param properties\n * @returns {boolean}\n */\nfunction hasProperties(obj, ...properties) {\n  return properties.filter(key => {\n    return typeof obj[key] !== 'undefined';\n  }).length > 0;\n}\n\n/**\n * Returns typecasted value.\n * External generators (faker, chance, casual) may return data in non-expected formats, such as string, when you might expect an\n * integer. This function is used to force the typecast. This is the base formatter for all result values.\n *\n * @param type\n * @param schema\n * @param callback\n * @returns {any}\n */\nfunction typecast(type, schema, callback) {\n  const params = {};\n\n  // normalize constraints\n  switch (type || schema.type) {\n    case 'integer':\n    case 'number':\n      if (typeof schema.minimum !== 'undefined') {\n        params.minimum = schema.minimum;\n      }\n\n      if (typeof schema.maximum !== 'undefined') {\n        params.maximum = schema.maximum;\n      }\n\n      if (schema.enum) {\n        let min = Math.max(params.minimum || 0, 0);\n        let max = Math.min(params.maximum || Infinity, Infinity);\n\n        if (schema.exclusiveMinimum && min === schema.minimum) {\n          min += schema.multipleOf || 1;\n        }\n\n        if (schema.exclusiveMaximum && max === schema.maximum) {\n          max -= schema.multipleOf || 1;\n        }\n\n        // discard out-of-bounds enumerations\n        if (min || max !== Infinity) {\n          schema.enum = schema.enum.filter(x => {\n            if (x >= min && x <= max) {\n              return true;\n            }\n\n            return false;\n          });\n        }\n      }\n\n      break;\n\n    case 'string': {\n      if (typeof schema.minLength !== 'undefined') {\n        params.minLength = schema.minLength;\n      }\n\n      if (typeof schema.maxLength !== 'undefined') {\n        params.maxLength = schema.maxLength;\n      }\n\n      const _maxLength = optionAPI('maxLength');\n      const _minLength = optionAPI('minLength');\n\n      // Don't allow user to set max length above our maximum\n      if (_maxLength && params.maxLength > _maxLength) {\n        params.maxLength = _maxLength;\n      }\n\n      // Don't allow user to set min length above our maximum\n      if (_minLength && params.minLength < _minLength) {\n        params.minLength = _minLength;\n      }\n\n      break;\n    }\n\n    default: break;\n  }\n\n  // execute generator\n  let value = callback(params);\n\n  // normalize output value\n  switch (type || schema.type) {\n    case 'number':\n      value = parseFloat(value);\n      break;\n\n    case 'integer':\n      value = parseInt(value, 10);\n      break;\n\n    case 'boolean':\n      value = !!value;\n      break;\n\n    case 'string': {\n      value = String(value);\n\n      const min = Math.max(params.minLength || 0, 0);\n      const max = Math.min(params.maxLength || Infinity, Infinity);\n\n      while (value.length < min) {\n        if (!schema.pattern) {\n          value += `${random.pick([' ', '/', '_', '-', '+', '=', '@', '^'])}${value}`;\n        } else {\n          value += random.randexp(schema.pattern);\n        }\n      }\n\n      if (value.length > max) {\n        value = value.substr(0, max);\n      }\n\n      switch (schema.format) {\n        case 'date-time':\n        case 'datetime':\n          value = new Date(value).toISOString().replace(/([0-9])0+Z$/, '$1Z');\n          break;\n\n        case 'date':\n          value = new Date(value).toISOString().substr(0, 10);\n          break;\n\n        case 'time':\n          value = new Date(`1969-01-01 ${value}`).toISOString().substr(11);\n          break;\n\n        default:\n          break;\n      }\n      break;\n    }\n\n    default: break;\n  }\n\n  return value;\n}\n\nfunction merge(a, b) {\n  Object.keys(b).forEach(key => {\n    if (typeof b[key] !== 'object' || b[key] === null) {\n      a[key] = b[key];\n    } else if (Array.isArray(b[key])) {\n      a[key] = a[key] || [];\n      // fix #292 - skip duplicated values from merge object (b)\n      b[key].forEach(value => {\n        if (a[key].indexOf(value) === -1) {\n          a[key].push(value);\n        }\n      });\n    } else if (typeof a[key] !== 'object' || a[key] === null || Array.isArray(a[key])) {\n      a[key] = merge({}, b[key]);\n    } else {\n      a[key] = merge(a[key], b[key]);\n    }\n  });\n\n  return a;\n}\n\nfunction clone(obj) {\n  if (!obj || typeof obj !== 'object') {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(x => clone(x));\n  }\n\n  return Object.keys(obj).reduce((prev, cur) => {\n    prev[cur] = clone(obj[cur]);\n    return prev;\n  }, {});\n}\n\nfunction short(schema) {\n  const s = JSON.stringify(schema);\n  const l = JSON.stringify(schema, null, 2);\n\n  return s.length > 400 ? `${l.substr(0, 400)}...` : l;\n}\n\nfunction anyValue() {\n  return random.pick([\n    false,\n    true,\n    null,\n    -1,\n    NaN,\n    Math.PI,\n    Infinity,\n    undefined,\n    [],\n    {},\n    // FIXME: use built-in random?\n    Math.random(),\n    Math.random().toString(36).substr(2),\n  ]);\n}\n\nfunction notValue(schema, parent) {\n  const copy = merge({}, parent);\n\n  if (typeof schema.minimum !== 'undefined') {\n    copy.maximum = schema.minimum;\n    copy.exclusiveMaximum = true;\n  }\n\n  if (typeof schema.maximum !== 'undefined') {\n    copy.minimum = schema.maximum > copy.maximum ? 0 : schema.maximum;\n    copy.exclusiveMinimum = true;\n  }\n\n  if (typeof schema.minLength !== 'undefined') {\n    copy.maxLength = schema.minLength;\n  }\n\n  if (typeof schema.maxLength !== 'undefined') {\n    copy.minLength = schema.maxLength > copy.maxLength ? 0 : schema.maxLength;\n  }\n\n  if (schema.type) {\n    copy.type = random.pick(env.ALL_TYPES.filter(x => {\n      const types = Array.isArray(schema.type) ? schema.type : [schema.type];\n\n      return types.every(type => {\n        // treat both types as _similar enough_ to be skipped equal\n        if (x === 'number' || x === 'integer') {\n          return type !== 'number' && type !== 'integer';\n        }\n\n        return x !== type;\n      });\n    }));\n  } else if (schema.enum) {\n    let value;\n\n    do {\n      value = anyValue();\n    } while (schema.enum.indexOf(value) !== -1);\n\n    copy.enum = [value];\n  }\n\n  if (schema.required && copy.properties) {\n    schema.required.forEach(prop => {\n      delete copy.properties[prop];\n    });\n  }\n\n  // TODO: explore more scenarios\n\n  return copy;\n}\n\n// FIXME: evaluate more constraints?\nfunction validate(value, schemas) {\n  return !schemas.every(x => {\n    if (typeof x.minimum !== 'undefined' && value >= x.minimum) {\n      return true;\n    }\n\n    if (typeof x.maximum !== 'undefined' && value <= x.maximum) {\n      return true;\n    }\n\n    return false;\n  });\n}\n\nfunction isKey(prop) {\n  return ['enum', 'const', 'default', 'examples', 'required', 'definitions'].indexOf(prop) !== -1;\n}\n\nfunction omitProps(obj, props) {\n  const copy = {};\n\n  Object.keys(obj).forEach(k => {\n    if (props.indexOf(k) === -1) {\n      if (Array.isArray(obj[k])) {\n        copy[k] = obj[k].slice();\n      } else {\n        copy[k] = obj[k] instanceof Object\n          ? merge({}, obj[k])\n          : obj[k];\n      }\n    }\n  });\n\n  return copy;\n}\n\nfunction template(value, schema) {\n  if (Array.isArray(value)) {\n    return value.map(x => template(x, schema));\n  }\n\n  if (typeof value === 'string') {\n    value = value.replace(/#\\{([\\w.-]+)\\}/g, (_, $1) => schema[$1]);\n  }\n\n  return value;\n}\n\nexport default {\n  getSubAttribute,\n  hasProperties,\n  omitProps,\n  typecast,\n  merge,\n  clone,\n  short,\n  notValue,\n  anyValue,\n  validate,\n  isKey,\n  template,\n};\n","import util from '../core/utils';\n\n// dynamic proxy for custom generators\nfunction proxy(gen) {\n  return (value, schema, property, rootSchema) => {\n    let fn = value;\n    let args = [];\n\n    // support for nested object, first-key is the generator\n    if (typeof value === 'object') {\n      fn = Object.keys(value)[0];\n\n      // treat the given array as arguments,\n      if (Array.isArray(value[fn])) {\n        // if the generator is expecting arrays they should be nested, e.g. `[[1, 2, 3], true, ...]`\n        args = value[fn];\n      } else {\n        args.push(value[fn]);\n      }\n    }\n\n    // support for keypaths, e.g. \"internet.email\"\n    const props = fn.split('.');\n\n    // retrieve a fresh dependency\n    let ctx = gen();\n\n    while (props.length > 1) {\n      ctx = ctx[props.shift()];\n    }\n\n    // retrieve last value from context object\n    value = typeof ctx === 'object' ? ctx[props[0]] : ctx;\n\n    // invoke dynamic generators\n    if (typeof value === 'function') {\n      value = value.apply(ctx, args.map(x => util.template(x, rootSchema)));\n    }\n\n    // test for pending callbacks\n    if (Object.prototype.toString.call(value) === '[object Object]') {\n      Object.keys(value).forEach(key => {\n        if (typeof value[key] === 'function') {\n          throw new Error(`Cannot resolve value for '${property}: ${fn}', given: ${value}`);\n        }\n      });\n    }\n\n    return value;\n  };\n}\n\n/**\n * Container is used to wrap external generators (faker, chance, casual, etc.) and its dependencies.\n *\n * - `jsf.extend('faker')` will enhance or define the given dependency.\n * - `jsf.define('faker')` will provide the \"faker\" keyword support.\n *\n * RandExp is not longer considered an \"extension\".\n */\nclass Container {\n  constructor() {\n    // dynamic requires - handle all dependencies\n    // they will NOT be included on the bundle\n    this.registry = {};\n    this.support = {};\n  }\n\n  /**\n   * Unregister extensions\n   * @param name\n   */\n  reset(name) {\n    if (!name) {\n      this.registry = {};\n      this.support = {};\n    } else {\n      delete this.registry[name];\n      delete this.support[name];\n    }\n  }\n\n  /**\n   * Override dependency given by name\n   * @param name\n   * @param callback\n   */\n  extend(name, callback) {\n    this.registry[name] = callback(this.registry[name]);\n\n    // built-in proxy (can be overridden)\n    if (!this.support[name]) {\n      this.support[name] = proxy(() => this.registry[name]);\n    }\n  }\n\n  /**\n   * Set keyword support by name\n   * @param name\n   * @param callback\n   */\n  define(name, callback) {\n    this.support[name] = callback;\n  }\n\n  /**\n   * Returns dependency given by name\n   * @param name\n   * @returns {Dependency}\n   */\n  get(name) {\n    if (typeof this.registry[name] === 'undefined') {\n      throw new ReferenceError(`'${name}' dependency doesn't exist.`);\n    }\n    return this.registry[name];\n  }\n\n  /**\n   * Apply a custom keyword\n   * @param schema\n   */\n  wrap(schema) {\n    const keys = Object.keys(schema);\n    const context = {};\n\n    let length = keys.length;\n\n    while (length--) { // eslint-disable-line\n      const fn = keys[length].replace(/^x-/, '');\n      const gen = this.support[fn];\n\n      if (typeof gen === 'function') {\n        Object.defineProperty(schema, 'generate', {\n          configurable: false,\n          enumerable: false,\n          writable: false,\n          value: rootSchema => gen.call(context, schema[keys[length]], schema, keys[length], rootSchema), // eslint-disable-line\n        });\n        break;\n      }\n    }\n\n    return schema;\n  }\n}\n\nexport default Container;\n","import Registry from '../class/Registry';\n\n// instantiate\nconst registry = new Registry();\n\n/**\n * Custom format API\n *\n * @see https://github.com/json-schema-faker/json-schema-faker#custom-formats\n * @param nameOrFormatMap\n * @param callback\n * @returns {any}\n */\nfunction formatAPI(nameOrFormatMap, callback) {\n  if (typeof nameOrFormatMap === 'undefined') {\n    return registry.list();\n  }\n\n  if (typeof nameOrFormatMap === 'string') {\n    if (typeof callback === 'function') {\n      registry.register(nameOrFormatMap, callback);\n    } else if (callback === null || callback === false) {\n      registry.unregister(nameOrFormatMap);\n    } else {\n      return registry.get(nameOrFormatMap);\n    }\n  } else {\n    registry.registerMany(nameOrFormatMap);\n  }\n}\n\nexport default formatAPI;\n","class ParseError extends Error {\n  constructor(message, path) {\n    super();\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n    this.name = 'ParseError';\n    this.message = message;\n    this.path = path;\n  }\n}\n\nexport default ParseError;\n","const inferredProperties = {\n  array: [\n    'additionalItems',\n    'items',\n    'maxItems',\n    'minItems',\n    'uniqueItems',\n  ],\n  integer: [\n    'exclusiveMaximum',\n    'exclusiveMinimum',\n    'maximum',\n    'minimum',\n    'multipleOf',\n  ],\n  object: [\n    'additionalProperties',\n    'dependencies',\n    'maxProperties',\n    'minProperties',\n    'patternProperties',\n    'properties',\n    'required',\n  ],\n  string: [\n    'maxLength',\n    'minLength',\n    'pattern',\n    'format',\n  ],\n};\n\ninferredProperties.number = inferredProperties.integer;\n\nconst subschemaProperties = [\n  'additionalItems',\n  'items',\n  'additionalProperties',\n  'dependencies',\n  'patternProperties',\n  'properties',\n];\n\n/**\n * Iterates through all keys of `obj` and:\n * - checks whether those keys match properties of a given inferred type\n * - makes sure that `obj` is not a subschema; _Do not attempt to infer properties named as subschema containers. The\n * reason for this is that any property name within those containers that matches one of the properties used for\n * inferring missing type values causes the container itself to get processed which leads to invalid output. (Issue 62)_\n *\n * @returns {boolean}\n */\nfunction matchesType(obj, lastElementInPath, inferredTypeProperties) {\n  return Object.keys(obj).filter(prop => {\n    const isSubschema = subschemaProperties.indexOf(lastElementInPath) > -1;\n    const inferredPropertyFound = inferredTypeProperties.indexOf(prop) > -1;\n\n    if (inferredPropertyFound && !isSubschema) {\n      return true;\n    }\n\n    return false;\n  }).length > 0;\n}\n\n/**\n * Checks whether given `obj` type might be inferred. The mechanism iterates through all inferred types definitions,\n * tries to match allowed properties with properties of given `obj`. Returns type name, if inferred, or null.\n *\n * @returns {string|null}\n */\nfunction inferType(obj, schemaPath) {\n  const keys = Object.keys(inferredProperties);\n\n  for (let i = 0; i < keys.length; i += 1) {\n    const typeName = keys[i];\n    const lastElementInPath = schemaPath[schemaPath.length - 1];\n\n    if (matchesType(obj, lastElementInPath, inferredProperties[typeName])) {\n      return typeName;\n    }\n  }\n}\n\nexport default inferType;\n","import booleanGenerator from '../generators/boolean';\n\nconst booleanType = booleanGenerator;\n\nexport default booleanType;\n","import optionAPI from '../api/option';\n\n/**\n * Generates randomized boolean value.\n *\n * @returns {boolean}\n */\nfunction booleanGenerator() {\n  return optionAPI('random')() > 0.5;\n}\n\nexport default booleanGenerator;\n","import nullGenerator from '../generators/null';\n\nconst nullType = nullGenerator;\n\nexport default nullType;\n","/**\n * Generates null value.\n *\n * @returns {null}\n */\nfunction nullGenerator() {\n  return null;\n}\n\nexport default nullGenerator;\n","import random from '../core/random';\nimport env from '../core/constants';\n\nfunction numberType(value) {\n  let min = typeof value.minimum === 'undefined' ? env.MIN_INTEGER : value.minimum;\n  let max = typeof value.maximum === 'undefined' ? env.MAX_INTEGER : value.maximum;\n\n  const multipleOf = value.multipleOf;\n\n  if (multipleOf) {\n    max = Math.floor(max / multipleOf) * multipleOf;\n    min = Math.ceil(min / multipleOf) * multipleOf;\n  }\n\n  if (value.exclusiveMinimum && min === value.minimum) {\n    min += multipleOf || 1;\n  }\n\n  if (value.exclusiveMaximum && max === value.maximum) {\n    max -= multipleOf || 1;\n  }\n\n  if (min > max) {\n    return NaN;\n  }\n\n  if (multipleOf) {\n    if (String(multipleOf).indexOf('.') === -1) {\n      let base = random.number(Math.floor(min / multipleOf), Math.floor(max / multipleOf)) * multipleOf;\n\n      while (base < min) {\n        base += value.multipleOf;\n      }\n\n      return base;\n    }\n\n    const boundary = (max - min) / multipleOf;\n\n    let num;\n    let fix;\n\n    do {\n      num = random.number(0, boundary) * multipleOf;\n      fix = (num / multipleOf) % 1;\n    } while (fix !== 0);\n\n    // FIXME: https://github.com/json-schema-faker/json-schema-faker/issues/379\n\n    return num;\n  }\n\n  return random.number(min, max, undefined, undefined, true);\n}\n\nexport default numberType;\n","import random from '../core/random';\n\nconst LIPSUM_WORDS = `Lorem ipsum dolor sit amet consectetur adipisicing elit sed do eiusmod tempor incididunt ut labore\net dolore magna aliqua Ut enim ad minim veniam quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea\ncommodo consequat Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla\npariatur Excepteur sint occaecat cupidatat non proident sunt in culpa qui officia deserunt mollit anim id est\nlaborum`.split(/\\W/);\n\n/**\n * Generates randomized array of single lorem ipsum words.\n *\n * @param length\n * @returns {Array.<string>}\n */\nfunction wordsGenerator(length) {\n  const words = random.shuffle(LIPSUM_WORDS);\n\n  return words.slice(0, length);\n}\n\nexport default wordsGenerator;\n","import random from '../core/random';\nimport words from '../generators/words';\nimport utils from '../core/utils';\nimport optionAPI from '../api/option';\n\n// fallback generator\nconst anyType = { type: ['string', 'number', 'integer', 'boolean'] };\n\n// TODO provide types\nfunction objectType(value, path, resolve, traverseCallback) {\n  const props = {};\n\n  const properties = value.properties || {};\n  const patternProperties = value.patternProperties || {};\n  const requiredProperties = typeof value.required === 'boolean' ? [] : (value.required || []).slice();\n  const allowsAdditional = value.additionalProperties !== false;\n\n  const propertyKeys = Object.keys(properties);\n  const patternPropertyKeys = Object.keys(patternProperties);\n  const optionalProperties = propertyKeys.concat(patternPropertyKeys).reduce((_response, _key) => {\n    if (requiredProperties.indexOf(_key) === -1) _response.push(_key);\n    return _response;\n  }, []);\n  const allProperties = requiredProperties.concat(optionalProperties);\n\n  const additionalProperties = allowsAdditional // eslint-disable-line\n    ? (value.additionalProperties === true ? anyType : value.additionalProperties)\n    : value.additionalProperties;\n\n  if (!allowsAdditional\n    && propertyKeys.length === 0\n    && patternPropertyKeys.length === 0\n    && utils.hasProperties(value, 'minProperties', 'maxProperties', 'dependencies', 'required')\n  ) {\n    // just nothing\n    return {};\n  }\n\n  if (optionAPI('requiredOnly') === true) {\n    requiredProperties.forEach(key => {\n      if (properties[key]) {\n        props[key] = properties[key];\n      }\n    });\n\n    return traverseCallback(props, path.concat(['properties']), resolve);\n  }\n\n  const optionalsProbability = optionAPI('alwaysFakeOptionals') === true ? 1.0 : optionAPI('optionalsProbability');\n  const fixedProbabilities = optionAPI('alwaysFakeOptionals') || optionAPI('fixedProbabilities') || false;\n  const ignoreProperties = optionAPI('ignoreProperties') || [];\n\n  const min = Math.max(value.minProperties || 0, requiredProperties.length);\n  const max = value.maxProperties || (allProperties.length + random.number(1, 5));\n\n  let neededExtras = Math.max(0, min - requiredProperties.length);\n\n  if (allProperties.length === 1 && !requiredProperties.length) {\n    neededExtras = random.number(neededExtras, allProperties.length + (allProperties.length - min));\n  }\n\n  if (optionalsProbability !== false) {\n    if (fixedProbabilities === true) {\n      neededExtras = Math.round((min - requiredProperties.length) + (optionalsProbability * (allProperties.length - min)));\n    } else {\n      neededExtras = random.number(min - requiredProperties.length, optionalsProbability * (allProperties.length - min));\n    }\n  }\n\n  const extraPropertiesRandomOrder = random.shuffle(optionalProperties).slice(0, neededExtras);\n  const extraProperties = optionalProperties.filter(_item => {\n    return extraPropertiesRandomOrder.indexOf(_item) !== -1;\n  });\n\n  // properties are read from right-to-left\n  const _props = requiredProperties.concat(extraProperties).slice(0, max);\n  const _defns = [];\n\n  if (value.dependencies) {\n    Object.keys(value.dependencies).forEach(prop => {\n      const _required = value.dependencies[prop];\n\n      if (_props.indexOf(prop) !== -1) {\n        if (Array.isArray(_required)) {\n          // property-dependencies\n          _required.forEach(sub => {\n            if (_props.indexOf(sub) === -1) {\n              _props.push(sub);\n            }\n          });\n        } else {\n          _defns.push(_required);\n        }\n      }\n    });\n\n    // schema-dependencies\n    if (_defns.length) {\n      delete value.dependencies;\n\n      return traverseCallback({\n        allOf: _defns.concat(value),\n      }, path.concat(['properties']), resolve);\n    }\n  }\n\n  const skipped = [];\n  const missing = [];\n\n  _props.forEach(key => {\n    for (let i = 0; i < ignoreProperties.length; i += 1) {\n      if ((ignoreProperties[i] instanceof RegExp && ignoreProperties[i].test(key))\n        || (typeof ignoreProperties[i] === 'string' && ignoreProperties[i] === key)\n        || (typeof ignoreProperties[i] === 'function' && ignoreProperties[i](properties[key], key))) {\n        skipped.push(key);\n        return;\n      }\n    }\n\n    if (additionalProperties === false) {\n      if (requiredProperties.indexOf(key) !== -1) {\n        props[key] = properties[key];\n      }\n    } else if (properties[key]) {\n      props[key] = properties[key];\n    }\n\n    let found;\n\n    // then try patternProperties\n    patternPropertyKeys.forEach(_key => {\n      if (key.match(new RegExp(_key))) {\n        found = true;\n\n        if (props[key]) {\n          utils.merge(props[key], patternProperties[_key]);\n        } else {\n          props[random.randexp(key)] = patternProperties[_key];\n        }\n      }\n    });\n\n    if (!found) {\n      // try patternProperties again,\n      const subschema = patternProperties[key] || additionalProperties;\n\n      // FIXME: allow anyType as fallback when no subschema is given?\n\n      if (subschema && additionalProperties !== false) {\n        // otherwise we can use additionalProperties?\n        props[patternProperties[key] ? random.randexp(key) : key] = properties[key] || subschema;\n      } else {\n        missing.push(key);\n      }\n    }\n  });\n\n  const fillProps = optionAPI('fillProperties');\n  const reuseProps = optionAPI('reuseProperties');\n\n  // discard already ignored props if they're not required to be filled...\n  let current = Object.keys(props).length + (fillProps ? 0 : skipped.length);\n\n  // generate dynamic suffix for additional props...\n  const hash = suffix => random.randexp(`_?[_a-f\\\\d]{1,3}${suffix ? '\\\\$?' : ''}`);\n\n  function get() {\n    let one;\n\n    do {\n      one = requiredProperties.shift();\n    } while (props[one]);\n\n    return one;\n  }\n\n  while (fillProps) {\n    if (!(patternPropertyKeys.length || allowsAdditional)) {\n      break;\n    }\n\n    if (current >= min) {\n      break;\n    }\n\n    if (allowsAdditional) {\n      if (reuseProps && ((propertyKeys.length - current) > min)) {\n        let count = 0;\n        let key;\n\n        do {\n          count += 1;\n\n          // skip large objects\n          if (count > 1000) {\n            break;\n          }\n\n          key = get() || random.pick(propertyKeys);\n        } while (typeof props[key] !== 'undefined');\n\n        if (typeof props[key] === 'undefined') {\n          props[key] = properties[key];\n          current += 1;\n        }\n      } else if (patternPropertyKeys.length && !additionalProperties) {\n        const prop = random.pick(patternPropertyKeys);\n        const word = random.randexp(prop);\n\n        if (!props[word]) {\n          props[word] = patternProperties[prop];\n          current += 1;\n        }\n      } else {\n        const word = get() || (words(1) + hash());\n\n        if (!props[word]) {\n          props[word] = additionalProperties || anyType;\n          current += 1;\n        }\n      }\n    }\n\n    for (let i = 0; current < min && i < patternPropertyKeys.length; i += 1) {\n      const _key = patternPropertyKeys[i];\n      const word = random.randexp(_key);\n\n\n      if (!props[word]) {\n        props[word] = patternProperties[_key];\n        current += 1;\n      }\n    }\n  }\n\n  // fill up-to this value and no more!\n  const maximum = random.number(min, max);\n\n  for (; current < maximum && additionalProperties;) {\n    const word = words(1) + hash(true);\n\n    if (!props[word]) {\n      props[word] = additionalProperties;\n      current += 1;\n    }\n  }\n\n  return traverseCallback(props, path.concat(['properties']), resolve);\n}\n\nexport default objectType;\n","import words from './words';\nimport random from '../core/random';\n\n/**\n * Helper function used by thunkGenerator to produce some words for the final result.\n *\n * @returns {string}\n */\nfunction produce() {\n  const length = random.number(1, 5);\n\n  return words(length).join(' ');\n}\n\n/**\n * Generates randomized concatenated string based on words generator.\n *\n * @returns {string}\n */\nfunction thunkGenerator(min = 0, max = 140) {\n  const _min = Math.max(0, min);\n  const _max = random.number(_min, max);\n\n  let result = produce();\n\n  // append until length is reached\n  while (result.length < _min) {\n    result += produce();\n  }\n\n  // cut if needed\n  if (result.length > _max) {\n    result = result.substr(0, _max);\n  }\n\n  return result;\n}\n\nexport default thunkGenerator;\n","import random from '../core/random';\n\n/**\n * Generates randomized date time ISO format string.\n *\n * @returns {string}\n */\nfunction dateTimeGenerator() {\n  return random.date().toISOString();\n}\n\nexport default dateTimeGenerator;\n","import random from '../core/random';\n\nconst FRAGMENT = '[a-zA-Z][a-zA-Z0-9+-.]*';\nconst URI_PATTERN = `https?://{hostname}(?:${FRAGMENT})+`;\nconst PARAM_PATTERN = '(?:\\\\?([a-z]{1,7}(=\\\\w{1,5})?&){0,3})?';\n\n/**\n * Predefined core formats\n * @type {[key: string]: string}\n */\nconst regexps = {\n  email: '[a-zA-Z\\\\d][a-zA-Z\\\\d-]{1,13}[a-zA-Z\\\\d]@{hostname}',\n  hostname: '[a-zA-Z]{1,33}\\\\.[a-z]{2,4}',\n  ipv6: '[a-f\\\\d]{4}(:[a-f\\\\d]{4}){7}',\n  uri: URI_PATTERN,\n  slug: '[a-zA-Z\\\\d_-]+',\n\n  // types from draft-0[67] (?)\n  'uri-reference': `${URI_PATTERN}${PARAM_PATTERN}`,\n  'uri-template': URI_PATTERN.replace('(?:', '(?:/\\\\{[a-z][:a-zA-Z0-9-]*\\\\}|'),\n  'json-pointer': `(/(?:${FRAGMENT.replace(']*', '/]*')}|~[01]))+`,\n\n  // some types from https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.1.md#data-types (?)\n  uuid: '^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$',\n};\n\nregexps.iri = regexps['uri-reference'];\nregexps['iri-reference'] = regexps['uri-reference'];\n\nregexps['idn-email'] = regexps.email;\nregexps['idn-hostname'] = regexps.hostname;\n\nconst ALLOWED_FORMATS = new RegExp(`\\\\{(${Object.keys(regexps).join('|')})\\\\}`);\n\n/**\n * Generates randomized string basing on a built-in regex format\n *\n * @param coreFormat\n * @returns {string}\n */\nfunction coreFormatGenerator(coreFormat) {\n  return random.randexp(regexps[coreFormat]).replace(ALLOWED_FORMATS, (match, key) => {\n    return random.randexp(regexps[key]);\n  });\n}\n\nexport default coreFormatGenerator;\n","import thunk from '../generators/thunk';\nimport ipv4 from '../generators/ipv4';\nimport dateTime from '../generators/dateTime';\nimport date from '../generators/date';\nimport time from '../generators/time';\nimport coreFormat from '../generators/coreFormat';\nimport optionAPI from '../api/option';\nimport format from '../api/format';\nimport random from '../core/random';\nimport utils from '../core/utils';\n\nfunction generateFormat(value, invalid) {\n  const callback = format(value.format);\n\n  if (typeof callback === 'function') {\n    return callback(value);\n  }\n\n  switch (value.format) {\n    case 'date-time':\n    case 'datetime':\n      return dateTime();\n    case 'date':\n      return date();\n    case 'time':\n      return time();\n    case 'ipv4':\n      return ipv4();\n    case 'regex':\n      // TODO: discuss\n      return '.+?';\n    case 'email':\n    case 'hostname':\n    case 'ipv6':\n    case 'uri':\n    case 'uri-reference':\n    case 'iri':\n    case 'iri-reference':\n    case 'idn-email':\n    case 'idn-hostname':\n    case 'json-pointer':\n    case 'slug':\n    case 'uri-template':\n    case 'uuid':\n      return coreFormat(value.format);\n    default:\n      if (typeof callback === 'undefined') {\n        if (optionAPI('failOnInvalidFormat')) {\n          throw new Error(`unknown registry key ${utils.short(value.format)}`);\n        } else {\n          return invalid();\n        }\n      }\n\n      throw new Error(`unsupported format '${value.format}'`);\n  }\n}\n\nfunction stringType(value) {\n  // here we need to force type to fix #467\n  const output = utils.typecast('string', value, opts => {\n    if (value.format) {\n      return generateFormat(value, () => thunk(opts.minLength, opts.maxLength));\n    }\n\n    if (value.pattern) {\n      return random.randexp(value.pattern);\n    }\n\n    return thunk(opts.minLength, opts.maxLength);\n  });\n\n  return output;\n}\n\nexport default stringType;\n","import dateTimeGenerator from './dateTime';\n\n/**\n * Generates randomized date format string.\n *\n * @returns {string}\n */\nfunction dateGenerator() {\n  return dateTimeGenerator().slice(0, 10);\n}\n\nexport default dateGenerator;\n","import dateTimeGenerator from './dateTime';\n\n/**\n * Generates randomized time format string.\n *\n * @returns {string}\n */\nfunction timeGenerator() {\n  return dateTimeGenerator().slice(11);\n}\n\nexport default timeGenerator;\n","import random from '../core/random';\n\n/**\n * Generates randomized ipv4 address.\n *\n * @returns {string}\n */\nfunction ipv4Generator() {\n  return [0, 0, 0, 0].map(() => {\n    return random.number(0, 255);\n  }).join('.');\n}\n\nexport default ipv4Generator;\n","import _boolean from './boolean';\nimport _null from './null';\nimport _array from './array';\nimport _integer from './integer';\nimport _number from './number';\nimport _object from './object';\nimport _string from './string';\n\nconst typeMap = {\n  boolean: _boolean,\n  null: _null,\n  array: _array,\n  integer: _integer,\n  number: _number,\n  object: _object,\n  string: _string,\n};\n\nexport default typeMap;\n","import random from '../core/random';\nimport utils from '../core/utils';\nimport ParseError from '../core/error';\nimport optionAPI from '../api/option';\n\n// TODO provide types\nfunction unique(path, items, value, sample, resolve, traverseCallback) {\n  const tmp = [];\n  const seen = [];\n\n  function walk(obj) {\n    const json = JSON.stringify(obj);\n\n    if (seen.indexOf(json) === -1) {\n      seen.push(json);\n      tmp.push(obj);\n\n      return true;\n    }\n\n    return false;\n  }\n\n  items.forEach(walk);\n\n  // TODO: find a better solution?\n  let limit = 100;\n\n  while (tmp.length !== items.length) {\n    if (!walk(traverseCallback(value.items || sample, path, resolve))) {\n      limit -= 1;\n    }\n\n    if (!limit) {\n      break;\n    }\n  }\n\n  return tmp;\n}\n\n// TODO provide types\nfunction arrayType(value, path, resolve, traverseCallback) {\n  const items = [];\n\n  if (!(value.items || value.additionalItems)) {\n    if (utils.hasProperties(value, 'minItems', 'maxItems', 'uniqueItems')) {\n      throw new ParseError(`missing items for ${utils.short(value)}`, path);\n    }\n    return items;\n  }\n\n  if (Array.isArray(value.items)) {\n    return value.items.map((item, key) => {\n      const itemSubpath = path.concat(['items', key]);\n\n      return traverseCallback(item, itemSubpath, resolve);\n    });\n  }\n\n  let minItems = value.minItems;\n  let maxItems = value.maxItems;\n\n  if (optionAPI('minItems')) {\n    // fix boundaries\n    minItems = !maxItems\n      ? optionAPI('minItems')\n      : Math.min(optionAPI('minItems'), maxItems);\n  }\n\n  if (optionAPI('maxItems')) {\n    // Don't allow user to set max items above our maximum\n    if (maxItems && maxItems > optionAPI('maxItems')) {\n      maxItems = optionAPI('maxItems');\n    }\n\n    // Don't allow user to set min items above our maximum\n    if (minItems && minItems > optionAPI('maxItems')) {\n      minItems = maxItems;\n    }\n  }\n\n  const optionalsProbability = optionAPI('alwaysFakeOptionals') === true ? 1.0 : optionAPI('optionalsProbability');\n  const fixedProbabilities = optionAPI('alwaysFakeOptionals') || optionAPI('fixedProbabilities') || false;\n\n  let length = random.number(minItems, maxItems, 1, 5);\n\n  if (optionalsProbability !== false) {\n    length = Math.max(fixedProbabilities\n      ? Math.round((maxItems || length) * optionalsProbability)\n      : Math.abs(random.number(minItems, maxItems) * optionalsProbability), minItems || 0);\n  }\n\n  // TODO below looks bad. Should additionalItems be copied as-is?\n  const sample = typeof value.additionalItems === 'object' ? value.additionalItems : {};\n\n  for (let current = items.length; current < length; current += 1) {\n    const itemSubpath = path.concat(['items', current]);\n    const element = traverseCallback(value.items || sample, itemSubpath, resolve);\n\n    items.push(element);\n  }\n\n  if (value.uniqueItems) {\n    return unique(path.concat(['items']), items, value, sample, resolve, traverseCallback);\n  }\n\n  return items;\n}\n\nexport default arrayType;\n","import number from './number';\n\n// The `integer` type is just a wrapper for the `number` type. The `number` type\n// returns floating point numbers, and `integer` type truncates the fraction\n// part, leaving the result as an integer.\n\nfunction integerType(value) {\n  return number({ multipleOf: 1, ...value });\n}\n\nexport default integerType;\n","import utils from './utils';\nimport random from './random';\nimport ParseError from './error';\nimport inferType from './infer';\nimport types from '../types/index';\nimport optionAPI from '../api/option';\n\n// TODO provide types\nfunction traverse(schema, path, resolve, rootSchema) {\n  schema = resolve(schema, undefined, path);\n\n  if (!schema) {\n    return;\n  }\n\n  // default values has higher precedence\n  if (path[path.length - 1] !== 'properties') {\n    // example values have highest precedence\n    if (optionAPI('useExamplesValue') && Array.isArray(schema.examples)) {\n      // include `default` value as example too\n      const fixedExamples = schema.examples\n        .concat('default' in schema ? [schema.default] : []);\n\n      return utils.typecast(null, schema, () => random.pick(fixedExamples));\n    }\n\n    if (optionAPI('useDefaultValue') && 'default' in schema) {\n      return schema.default;\n    }\n\n    if ('template' in schema) {\n      return utils.template(schema.template, rootSchema);\n    }\n  }\n\n  if (schema.not && typeof schema.not === 'object') {\n    schema = utils.notValue(schema.not, utils.omitProps(schema, ['not']));\n  }\n\n  if ('const' in schema) {\n    return schema.const;\n  }\n\n  if (Array.isArray(schema.enum)) {\n    return utils.typecast(null, schema, () => random.pick(schema.enum));\n  }\n\n  // thunks can return sub-schemas\n  if (typeof schema.thunk === 'function') {\n    return traverse(schema.thunk(), path, resolve);\n  }\n\n  if (typeof schema.generate === 'function') {\n    return utils.typecast(null, schema, () => schema.generate(rootSchema));\n  }\n\n  // TODO remove the ugly overcome\n  let type = schema.type;\n\n  if (Array.isArray(type)) {\n    type = random.pick(type);\n  } else if (typeof type === 'undefined') {\n    // Attempt to infer the type\n    type = inferType(schema, path) || type;\n\n    if (type) {\n      schema.type = type;\n    }\n  }\n\n  if (typeof type === 'string') {\n    if (!types[type]) {\n      if (optionAPI('failOnInvalidTypes')) {\n        throw new ParseError(`unknown primitive ${utils.short(type)}`, path.concat(['type']));\n      } else {\n        return optionAPI('defaultInvalidTypeProduct');\n      }\n    } else {\n      try {\n        return types[type](schema, path, resolve, traverse);\n      } catch (e) {\n        if (typeof e.path === 'undefined') {\n          throw new ParseError(e.stack, path);\n        }\n        throw e;\n      }\n    }\n  }\n\n  let copy = {};\n\n  if (Array.isArray(schema)) {\n    copy = [];\n  }\n\n  Object.keys(schema).forEach(prop => {\n    if (typeof schema[prop] === 'object' && prop !== 'definitions') {\n      copy[prop] = traverse(schema[prop], path.concat([prop]), resolve, copy);\n    } else {\n      copy[prop] = schema[prop];\n    }\n  });\n\n  return copy;\n}\n\nexport default traverse;\n","import { JSONPath } from 'jsonpath-plus';\n\nimport optionAPI from '../api/option';\nimport traverse from './traverse';\nimport random from './random';\nimport utils from './utils';\n\nfunction pick(data) {\n  return Array.isArray(data)\n    ? random.pick(data)\n    : data;\n}\n\nfunction cycle(data, reverse) {\n  if (!Array.isArray(data)) {\n    return data;\n  }\n\n  const value = reverse\n    ? data.pop()\n    : data.shift();\n\n  if (reverse) {\n    data.unshift(value);\n  } else {\n    data.push(value);\n  }\n\n  return value;\n}\n\nfunction resolve(obj, data, values, property) {\n  if (!obj || typeof obj !== 'object') {\n    return obj;\n  }\n\n  if (!values) {\n    values = {};\n  }\n\n  if (!data) {\n    data = obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(x => resolve(x, data, values, property));\n  }\n\n  if (obj.jsonPath) {\n    const params = typeof obj.jsonPath !== 'object'\n      ? { path: obj.jsonPath }\n      : obj.jsonPath;\n\n    params.group = obj.group || params.group || property;\n    params.cycle = obj.cycle || params.cycle || false;\n    params.reverse = obj.reverse || params.reverse || false;\n    params.count = obj.count || params.count || 1;\n\n    const key = `${params.group}__${params.path}`;\n\n    if (!values[key]) {\n      if (params.count > 1) {\n        values[key] = JSONPath(params.path, data).slice(0, params.count);\n      } else {\n        values[key] = JSONPath(params.path, data);\n      }\n    }\n\n    if (params.cycle || params.reverse) {\n      return cycle(values[key], params.reverse);\n    }\n\n    return pick(values[key]);\n  }\n\n  Object.keys(obj).forEach(k => {\n    obj[k] = resolve(obj[k], data, values, k);\n  });\n\n  return obj;\n}\n\n// TODO provide types\nfunction run(refs, schema, container) {\n  try {\n    const result = traverse(utils.clone(schema), [], function reduce(sub, maxReduceDepth, parentSchemaPath) {\n      if (typeof maxReduceDepth === 'undefined') {\n        maxReduceDepth = random.number(1, 3);\n      }\n\n      if (!sub) {\n        return null;\n      }\n\n      if (typeof sub.generate === 'function') {\n        return sub;\n      }\n\n      // cleanup\n      const _id = sub.$id || sub.id;\n\n      if (typeof _id === 'string') {\n        delete sub.id;\n        delete sub.$id;\n        delete sub.$schema;\n      }\n\n      if (typeof sub.$ref === 'string') {\n        if (sub.$ref === '#') {\n          delete sub.$ref;\n          return sub;\n        }\n\n        let ref;\n\n        if (sub.$ref.indexOf('#/') === -1) {\n          ref = refs[sub.$ref] || null;\n        }\n\n        if (sub.$ref.indexOf('#/definitions/') === 0) {\n          ref = schema.definitions[sub.$ref.split('#/definitions/')[1]] || null;\n        }\n\n        if (typeof ref !== 'undefined') {\n          if (!ref && optionAPI('ignoreMissingRefs') !== true) {\n            throw new Error(`Reference not found: ${sub.$ref}`);\n          }\n\n          utils.merge(sub, ref || {});\n        }\n\n        // just remove the reference\n        delete sub.$ref;\n        return sub;\n      }\n\n      if (Array.isArray(sub.allOf)) {\n        const schemas = sub.allOf;\n\n        delete sub.allOf;\n\n        // this is the only case where all sub-schemas\n        // must be resolved before any merge\n        schemas.forEach(subSchema => {\n          const _sub = reduce(subSchema, maxReduceDepth + 1, parentSchemaPath);\n\n          // call given thunks if present\n          utils.merge(sub, typeof _sub.thunk === 'function'\n            ? _sub.thunk()\n            : _sub);\n        });\n      }\n\n      if (Array.isArray(sub.oneOf || sub.anyOf)) {\n        const mix = sub.oneOf || sub.anyOf;\n\n        // test every value from the enum against each-oneOf\n        // schema, only values that validate once are kept\n        if (sub.enum && sub.oneOf) {\n          sub.enum = sub.enum.filter(x => utils.validate(x, mix));\n        }\n\n        return {\n          thunk() {\n            const copy = utils.omitProps(sub, ['anyOf', 'oneOf']);\n            const fixed = random.pick(mix);\n            utils.merge(copy, fixed);\n\n            if (sub.oneOf) {\n              mix.forEach(omit => {\n                if (omit !== fixed && omit.required) {\n                  omit.required.forEach(key => {\n                    delete copy.properties[key];\n                  });\n                }\n              });\n            }\n\n            return copy;\n          },\n        };\n      }\n\n      Object.keys(sub).forEach(prop => {\n        if ((Array.isArray(sub[prop]) || typeof sub[prop] === 'object') && !utils.isKey(prop)) {\n          sub[prop] = reduce(sub[prop], maxReduceDepth, parentSchemaPath.concat(prop));\n        }\n      });\n\n      // avoid extra calls on sub-schemas, fixes #458\n      if (parentSchemaPath) {\n        const lastProp = parentSchemaPath[parentSchemaPath.length - 1];\n\n        if (lastProp === 'properties' || lastProp === 'items') {\n          return sub;\n        }\n      }\n\n      return container.wrap(sub);\n    });\n\n    if (optionAPI('resolveJsonPath')) {\n      return resolve(result);\n    }\n\n    return result;\n  } catch (e) {\n    if (e.path) {\n      throw new Error(`${e.message} in /${e.path.join('/')}`);\n    } else {\n      throw e;\n    }\n  }\n}\n\nexport default run;\n","import $RefParser from 'json-schema-ref-parser';\n\nimport Container from './class/Container';\nimport format from './api/format';\nimport option from './api/option';\nimport env from './core/constants';\nimport random from './core/random';\nimport utils from './core/utils';\nimport run from './core/run';\n\nconst container = new Container();\n\nfunction setupKeywords() {\n  // built-in support\n  container.define('pattern', random.randexp);\n\n  // safe auto-increment values\n  container.define('autoIncrement', function autoIncrement(value, schema) {\n    if (!this.offset) {\n      const min = schema.minimum || 1;\n      const max = min + env.MAX_NUMBER;\n      const offset = value.initialOffset || schema.initialOffset;\n\n      this.offset = offset || random.number(min, max);\n    }\n\n    if (value === true) {\n      return this.offset++; // eslint-disable-line\n    }\n\n    return schema;\n  });\n\n  // safe-and-sequential dates\n  container.define('sequentialDate', function sequentialDate(value, schema) {\n    if (!this.now) {\n      this.now = random.date();\n    }\n\n    if (value) {\n      schema = this.now.toISOString();\n      value = value === true\n        ? 'days'\n        : value;\n\n      if (['seconds', 'minutes', 'hours', 'days', 'weeks', 'months', 'years'].indexOf(value) === -1) {\n        throw new Error(`Unsupported increment by ${utils.short(value)}`);\n      }\n\n      this.now.setTime(this.now.getTime() + random.date(value));\n    }\n\n    return schema;\n  });\n}\n\nfunction getRefs(refs) {\n  let $refs = {};\n\n  if (Array.isArray(refs)) {\n    refs.forEach(schema => {\n      $refs[schema.$id || schema.id] = schema;\n    });\n  } else {\n    $refs = refs || {};\n  }\n\n  return $refs;\n}\n\nconst jsf = (schema, refs, cwd) => {\n  console.log('[json-schema-faker] calling JsonSchemaFaker() is deprecated, call either .generate() or .resolve()');\n\n  if (cwd) {\n    console.log('[json-schema-faker] references are only supported by calling .resolve()');\n  }\n\n  return jsf.generate(schema, refs);\n};\n\njsf.generate = (schema, refs) => {\n  const $refs = getRefs(refs);\n\n  return run($refs, schema, container);\n};\n\njsf.resolve = (schema, refs, cwd) => {\n  if (typeof refs === 'string') {\n    cwd = refs;\n    refs = {};\n  }\n\n  // normalize basedir (browser aware)\n  cwd = cwd || (typeof process !== 'undefined' ? process.cwd() : '');\n  cwd = `${cwd.replace(/\\/+$/, '')}/`;\n\n  const $refs = getRefs(refs);\n\n  // identical setup as json-schema-sequelizer\n  const fixedRefs = {\n    order: 300,\n    canRead: true,\n    read(file, callback) {\n      try {\n        callback(null, $refs[file.url] || $refs[file.url.split('/').pop()]);\n      } catch (e) {\n        callback(e);\n      }\n    },\n  };\n\n  return $RefParser\n    .dereference(cwd, schema, {\n      resolve: {\n        file: { order: 100 },\n        http: { order: 200 },\n        fixedRefs,\n      },\n      dereference: {\n        circular: 'ignore',\n      },\n    }).then(sub => run($refs, sub, container));\n};\n\nsetupKeywords();\n\njsf.format = format;\njsf.option = option;\njsf.random = random;\n\n// returns itself for chaining\njsf.extend = (name, cb) => {\n  container.extend(name, cb);\n  return jsf;\n};\n\njsf.define = (name, cb) => {\n  container.define(name, cb);\n  return jsf;\n};\n\njsf.reset = name => {\n  container.reset(name);\n  setupKeywords();\n  return jsf;\n};\n\njsf.locate = name => {\n  return container.get(name);\n};\n\njsf.version = '0.5.0-rc19';\n\nexport default jsf;\n"],"names":["Registry","constructor","data","unregister","name","this","register","callback","registerMany","formats","keys","forEach","get","list","const","defaults","random","Math","registry","_defaults","optionAPI","nameOrOptionMap","optionalValue","getDefaults","ROOT","GROUP","POSITION","SET","RANGE","REPETITION","REFERENCE","CHAR","INTS","type","types","from","to","WORDS","value","concat","WHITESPACE","NOTANYCHAR","set","not","SLSH","0","t","n","v","f","r","exports","str","replace","s","b","lbs","a16","b16","c8","dctrl","eslsh","code","parseInt","indexOf","c","String","fromCharCode","test","regexpStr","rs","tokens","regexp","exec","push","sets","charCodeAt","lastIndex","error","msg","SyntaxError","l","i","start","stack","lastGroup","last","groupStack","repeatErr","util","strToChars","length","positions","classTokens","tokenizeClass","slice","group","remember","followedBy","notFollowedBy","pop","options","min","max","Infinity","SubRange","[object Object]","low","high","range","toString","DRange","a","ranges","add","reduce","previous","_add","subrange","touches","newRanges","_update_length","_subtract","overlaps","subtract","_intersect","index","join","RandExp","m","_setDefaults","RegExp","ignoreCase","multiline","source","Error","ret","prototype","defaultRange","clone","randInt","_gen","token","groups","undefined","groupNumber","_randSelect","expandedSet","_expand","_randBool","_toOtherCase","arr","drange","j","otherCaseCode","intersect","floor","_range","randexp","_randexp","gen","number","defMin","defMax","hasPrecision","env","MIN_NUMBER","MAX_NUMBER","getRandom","MIN_INTEGER","MAX_INTEGER","getRandomInteger","collection","step","by","now","Date","days","MOST_NEAR_DATETIME","setTime","getTime","tmp","key","copy","merge","Object","Array","isArray","anyValue","pick","NaN","PI","substr","obj","dotSeparatedKey","keyElements","split","prop","shift","properties","filter","props","k","schema","params","minimum","maximum","enum","exclusiveMinimum","multipleOf","exclusiveMaximum","x","minLength","maxLength","_maxLength","_minLength","parseFloat","pattern","format","toISOString","map","prev","cur","JSON","stringify","parent","ALL_TYPES","every","required","schemas","template","_","$1","Container","support","reset","extend","property","rootSchema","fn","args","ctx","apply","call","define","ReferenceError","wrap","context","defineProperty","formatAPI","nameOrFormatMap","ParseError","message","path","captureStackTrace","inferredProperties","array","integer","object","string","subschemaProperties","matchesType","lastElementInPath","inferredTypeProperties","isSubschema","booleanType","nullType","numberType","ceil","base","num","fix","boundary","LIPSUM_WORDS","wordsGenerator","shuffle","anyType","produce","words","thunkGenerator","_min","_max","result","dateTimeGenerator","date","URI_PATTERN","regexps","email","hostname","ipv6","uri","slug","uuid","iri","ALLOWED_FORMATS","generateFormat","invalid","coreFormat","dateTime","match","utils","short","typeMap","boolean","_boolean","null","_null","resolve","traverseCallback","items","additionalItems","hasProperties","item","itemSubpath","minItems","maxItems","optionalsProbability","fixedProbabilities","round","abs","sample","current","element","uniqueItems","seen","walk","json","limit","unique","_number","patternProperties","requiredProperties","allowsAdditional","additionalProperties","propertyKeys","patternPropertyKeys","optionalProperties","_response","_key","allProperties","ignoreProperties","minProperties","maxProperties","neededExtras","extraPropertiesRandomOrder","extraProperties","_item","_props","_defns","dependencies","_required","sub","allOf","skipped","let","found","subschema","fillProps","reuseProps","hash","suffix","one","count","word","typecast","opts","thunk","traverse","examples","fixedExamples","default","notValue","omitProps","generate","schemaPath","typeName","inferType","e","values","jsonPath","cycle","reverse","JSONPath","unshift","run","refs","container","maxReduceDepth","parentSchemaPath","$id","id","$schema","$ref","ref","definitions","subSchema","_sub","oneOf","anyOf","mix","validate","fixed","omit","isKey","lastProp","setupKeywords","offset","initialOffset","getRefs","$refs","jsf","cwd","console","log","process","fixedRefs","order","canRead","read","file","url","$RefParser","dereference","http","circular","then","option","cb","locate","version"],"mappings":";;;;;qXAGA,IAAMA,EACJC,gBAEOC,KAAO,IAOdC,YAAAA,oBAAWC,GACJA,SAGIC,KAAKH,KAAKE,QAFZF,KAAO,IAShBI,YAAAA,kBAASF,EAAMG,QACRL,KAAKE,GAAQG,GAMpBC,YAAAA,sBAAaC,qBACJC,KAAKD,GAASE,iBAAQP,KACtBF,KAAKE,GAAQK,EAAQL,MAO9BQ,YAAAA,aAAIR,UACaC,KAAKH,KAAKE,IAQ3BS,YAAAA,uBACSR,KAAKH,MChDhBY,IAAMC,EAAW,CAEjBA,0BAAqC,KACrCA,kBAA6B,GAE7BA,iBAA4B,GAC5BA,mBAA6B,EAC7BA,oBAA8B,EAC9BA,qBAA+B,EAE/BA,qBAA+B,EAC/BA,sBAAgC,EAChCA,oBAA8B,EAC9BA,kBAA4B,EAC5BA,iBAA2B,EAC3BA,cAAwB,EAExBA,SAAoB,EACpBA,SAAoB,KACpBA,UAAqB,EACrBA,UAAqB,KAErBA,iBAA2B,EAC3BA,iBAA2B,EAC3BA,gBAA0B,GAE1BA,EAASC,OAASC,KAAKD,OAKvB,IC9BME,EAAW,gBD+BfjB,+BAEOC,sBAAYa,QACZI,UAAYJ,qIAGfA,gDACUV,KAAKc,sDARQnB,ICtB7B,SAASoB,EAAUC,EAAiBC,SACH,iBAApBD,OACoB,IAAlBC,EACFJ,EAASZ,SAASe,EAAiBC,GAGrCJ,EAASN,IAAIS,GAGfH,EAASV,aAAaa,GAG/BD,EAAUG,8BAAoBL,EAASH,UCvBvCD,MAUe,WAVG,CAAC,QAAS,SAAU,UAAW,SAAU,SAAU,UAAW,oBAO5D,eACD,iBAJE,gBACD,uBAHO,WCF3B,MAAiB,CACfU,KAAa,EACbC,MAAa,EACbC,SAAa,EACbC,IAAa,EACbC,MAAa,EACbC,WAAa,EACbC,UAAa,EACbC,KAAa,GCNf,MAAMC,EAAO,IAAM,CAAC,CAAEC,KAAMC,EAAMN,MAAQO,KAAM,GAAIC,GAAI,KAElDC,EAAQ,IACL,CACL,CAAEJ,KAAMC,EAAMH,KAAMO,MAAO,IAC3B,CAAEL,KAAMC,EAAMN,MAAOO,KAAM,GAAIC,GAAI,KACnC,CAAEH,KAAMC,EAAMN,MAAOO,KAAM,GAAIC,GAAI,KACnCG,OAAOP,KAGLQ,EAAa,IACV,CACL,CAAEP,KAAMC,EAAMH,KAAMO,MAAO,GAC3B,CAAEL,KAAMC,EAAMH,KAAMO,MAAO,IAC3B,CAAEL,KAAMC,EAAMH,KAAMO,MAAO,IAC3B,CAAEL,KAAMC,EAAMH,KAAMO,MAAO,IAC3B,CAAEL,KAAMC,EAAMH,KAAMO,MAAO,IAC3B,CAAEL,KAAMC,EAAMH,KAAMO,MAAO,IAC3B,CAAEL,KAAMC,EAAMH,KAAMO,MAAO,KAC3B,CAAEL,KAAMC,EAAMH,KAAMO,MAAO,MAC3B,CAAEL,KAAMC,EAAMN,MAAOO,KAAM,KAAMC,GAAI,MACrC,CAAEH,KAAMC,EAAMH,KAAMO,MAAO,MAC3B,CAAEL,KAAMC,EAAMH,KAAMO,MAAO,MAC3B,CAAEL,KAAMC,EAAMH,KAAMO,MAAO,MAC3B,CAAEL,KAAMC,EAAMH,KAAMO,MAAO,MAC3B,CAAEL,KAAMC,EAAMH,KAAMO,MAAO,OAC3B,CAAEL,KAAMC,EAAMH,KAAMO,MAAO,QAIzBG,EAAa,IACV,CACL,CAAER,KAAMC,EAAMH,KAAMO,MAAO,IAC3B,CAAEL,KAAMC,EAAMH,KAAMO,MAAO,IAC3B,CAAEL,KAAMC,EAAMH,KAAMO,MAAO,MAC3B,CAAEL,KAAMC,EAAMH,KAAMO,MAAO,OAK/B,QAAgB,MAASL,KAAMC,EAAMP,IAAKe,IAAKL,IAASM,KAAK,MAC1C,MAASV,KAAMC,EAAMP,IAAKe,IAAKL,IAASM,KAAK,MACjD,MAASV,KAAMC,EAAMP,IAAKe,IAAKV,IAAQW,KAAK,MACzC,MAASV,KAAMC,EAAMP,IAAKe,IAAKV,IAAQW,KAAK,MACzC,MAASV,KAAMC,EAAMP,IAAKe,IAAKF,IAAcG,KAAK,MAC/C,MAASV,KAAMC,EAAMP,IAAKe,IAAKF,IAAcG,KAAK,MACxD,MAASV,KAAMC,EAAMP,IAAKe,IAAKD,IAAcE,KAAK,qBC5CpE,MACMC,EAAO,CAAEC,EAAK,EAAGC,EAAK,EAAGC,EAAK,GAAIC,EAAK,GAAIC,EAAK,GAAIC,EAAK,IAS/DC,aAAqB,SAASC,GAyB5B,OAtBAA,EAAMA,EAAIC,QADQ,+FACa,SAASC,EAAGC,EAAGC,EAAKC,EAAKC,EAAKC,EAAIC,EAAOC,GACtE,GAAIL,EACF,OAAOF,EAGT,IAAIQ,EAAOP,EAAI,EACbE,EAAQM,SAASN,EAAK,IACtBC,EAAQK,SAASL,EAAK,IACtBC,EAAQI,SAASJ,EAAM,GACvBC,EAtBO,qCAsBMI,QAAQJ,GACrBhB,EAAKiB,GAEHI,EAAIC,OAAOC,aAAaL,GAO5B,MAJI,mBAAmBM,KAAKH,KAC1BA,EAAI,KAAOA,GAGNA,KAeXd,gBAAwB,EAACC,EAAKiB,KAO5B,IALA,IAEIC,EAAIL,EAFJM,EAAS,GACTC,EAAS,4FAIqB,OAA1BF,EAAKE,EAAOC,KAAKrB,KACvB,GAAIkB,EAAG,GACLC,EAAOG,KAAKC,UAEP,GAAIL,EAAG,GACZC,EAAOG,KAAKC,UAEP,GAAIL,EAAG,GACZC,EAAOG,KAAKC,UAEP,GAAIL,EAAG,GACZC,EAAOG,KAAKC,UAEP,GAAIL,EAAG,GACZC,EAAOG,KAAKC,UAEP,GAAIL,EAAG,GACZC,EAAOG,KAAKC,UAEP,GAAIL,EAAG,GACZC,EAAOG,KAAK,CACVzC,KAAMC,EAAMN,MACZO,MAAOmC,EAAG,IAAMA,EAAG,IAAIM,WAAW,GAClCxC,GAAIkC,EAAG,IAAIM,WAAW,SAGnB,CAAA,KAAKX,EAAIK,EAAG,KAOjB,MAAO,CAACC,EAAQC,EAAOK,WANvBN,EAAOG,KAAK,CACVzC,KAAMC,EAAMH,KACZO,MAAO2B,EAAEW,WAAW,KAQ1BzB,EAAQ2B,MAAMT,EAAW,kCAU3BlB,QAAgB,EAACqB,EAAQO,KACvB,MAAM,IAAIC,YAAY,gCAAkCR,EAAS,MAAQO,mFCzGpD,MAAS9C,KAAMC,EAAMR,SAAUY,MAAO,SACnC,MAASL,KAAMC,EAAMR,SAAUY,MAAO,QAChD,MAASL,KAAMC,EAAMR,SAAUY,MAAO,QACxC,MAASL,KAAMC,EAAMR,SAAUY,MAAO,QCElC+B,IAChB,IAAWY,EAAGhB,EAAViB,EAAI,EACNC,EAAQ,CAAElD,KAAMC,EAAMV,KAAM4D,MAAO,IAGnCC,EAAYF,EACZG,EAAOH,EAAMC,MACbG,EAAa,GAGXC,EAAaN,IACfO,EAAKX,MAAMT,iCAA0Ca,EAAI,MAIvD9B,EAAMqC,EAAKC,WAAWrB,GAI1B,IAHAY,EAAI7B,EAAIuC,OAGDT,EAAID,GAGT,OAFAhB,EAAIb,EAAI8B,MAIN,IAAK,KAGH,OAFAjB,EAAIb,EAAI8B,MAGN,IAAK,IACHI,EAAKZ,KAAKkB,KACV,MAEF,IAAK,IACHN,EAAKZ,KAAKkB,KACV,MAEF,IAAK,IACHN,EAAKZ,KAAKC,KACV,MAEF,IAAK,IACHW,EAAKZ,KAAKC,KACV,MAEF,IAAK,IACHW,EAAKZ,KAAKC,KACV,MAEF,IAAK,IACHW,EAAKZ,KAAKC,KACV,MAEF,IAAK,IACHW,EAAKZ,KAAKC,KACV,MAEF,IAAK,IACHW,EAAKZ,KAAKC,KACV,MAEF,QAGM,KAAKP,KAAKH,GACZqB,EAAKZ,KAAK,CAAEzC,KAAMC,EAAMJ,UAAWQ,MAAOyB,SAASE,EAAG,MAItDqB,EAAKZ,KAAK,CAAEzC,KAAMC,EAAMH,KAAMO,MAAO2B,EAAEW,WAAW,KAIxD,MAIF,IAAK,IACHU,EAAKZ,KAAKkB,KACV,MAEF,IAAK,IACHN,EAAKZ,KAAKkB,KACV,MAIF,IAAK,IAEH,IAAIjD,EACW,MAAXS,EAAI8B,IACNvC,GAAM,EACNuC,KAEAvC,GAAM,EAIR,IAAIkD,EAAcJ,EAAKK,cAAc1C,EAAI2C,MAAMb,GAAIb,GAGnDa,GAAKW,EAAY,GACjBP,EAAKZ,KAAK,CACRzC,KAAMC,EAAMP,IACZe,IAAKmD,EAAY,GACjBlD,IAAAA,IAGF,MAIF,IAAK,IACH2C,EAAKZ,KAAKC,KACV,MAIF,IAAK,IAEH,IAAIqB,EAAQ,CACV/D,KAAMC,EAAMT,MACZ2D,MAAO,GACPa,UAAU,GAMF,OAHVhC,EAAIb,EAAI8B,MAINjB,EAAIb,EAAI8B,EAAI,GACZA,GAAK,EAGK,MAANjB,EACF+B,EAAME,YAAa,EAGJ,MAANjC,EACT+B,EAAMG,eAAgB,EAEP,MAANlC,GACTwB,EAAKX,MAAMT,+BACoBJ,6BACLiB,EAAI,KAGhCc,EAAMC,UAAW,GAInBX,EAAKZ,KAAKsB,GAGVT,EAAWb,KAAKW,GAGhBA,EAAYW,EACZV,EAAOU,EAAMZ,MACb,MAIF,IAAK,IACuB,IAAtBG,EAAWI,QACbF,EAAKX,MAAMT,2BAAoCa,EAAI,KAMrDI,GAJAD,EAAYE,EAAWa,OAINC,QACfhB,EAAUgB,QAAQhB,EAAUgB,QAAQV,OAAS,GAAKN,EAAUD,MAC9D,MAIF,IAAK,IAGEC,EAAUgB,UACbhB,EAAUgB,QAAU,CAAChB,EAAUD,cACxBC,EAAUD,OAInB,IAAIA,EAAQ,GACZC,EAAUgB,QAAQ3B,KAAKU,GACvBE,EAAOF,EACP,MAQF,IAAK,IACH,IAAkDkB,EAAKC,EAAnDjC,EAAK,qBAAqBG,KAAKrB,EAAI2C,MAAMb,IAClC,OAAPZ,GACkB,IAAhBgB,EAAKK,QACPH,EAAUN,GAEZoB,EAAMvC,SAASO,EAAG,GAAI,IACtBiC,EAAMjC,EAAG,GAAKA,EAAG,GAAKP,SAASO,EAAG,GAAI,IAAMkC,EAAAA,EAAWF,EACvDpB,GAAKZ,EAAG,GAAGqB,OAEXL,EAAKZ,KAAK,CACRzC,KAAMC,EAAML,WACZyE,IAAAA,EACAC,IAAAA,EACAjE,MAAOgD,EAAKc,SAGdd,EAAKZ,KAAK,CACRzC,KAAMC,EAAMH,KACZO,MAAO,MAGX,MAEF,IAAK,IACiB,IAAhBgD,EAAKK,QACPH,EAAUN,GAEZI,EAAKZ,KAAK,CACRzC,KAAMC,EAAML,WACZyE,IAAK,EACLC,IAAK,EACLjE,MAAOgD,EAAKc,QAEd,MAEF,IAAK,IACiB,IAAhBd,EAAKK,QACPH,EAAUN,GAEZI,EAAKZ,KAAK,CACRzC,KAAMC,EAAML,WACZyE,IAAK,EACLC,IAAKC,EAAAA,EACLlE,MAAOgD,EAAKc,QAEd,MAEF,IAAK,IACiB,IAAhBd,EAAKK,QACPH,EAAUN,GAEZI,EAAKZ,KAAK,CACRzC,KAAMC,EAAML,WACZyE,IAAK,EACLC,IAAKC,EAAAA,EACLlE,MAAOgD,EAAKc,QAEd,MAIF,QACEd,EAAKZ,KAAK,CACRzC,KAAMC,EAAMH,KACZO,MAAO2B,EAAEW,WAAW,KAW5B,OAJ0B,IAAtBW,EAAWI,QACbF,EAAKX,MAAMT,EAAW,sBAGjBc,GCjRT,MAAMsB,EACFC,YAAYC,EAAKC,GACbvG,KAAKsG,IAAMA,EACXtG,KAAKuG,KAAOA,EACZvG,KAAKsF,OAAS,EAAIiB,EAAOD,EAG7BD,SAASG,GACL,QAASxG,KAAKuG,KAAOC,EAAMF,KAAOtG,KAAKsG,IAAME,EAAMD,MAGvDF,QAAQG,GACJ,QAASxG,KAAKuG,KAAO,EAAIC,EAAMF,KAAOtG,KAAKsG,IAAM,EAAIE,EAAMD,MAI/DF,IAAIG,GACA,OAAO,IAAIJ,EACPxF,KAAKqF,IAAIjG,KAAKsG,IAAKE,EAAMF,KACzB1F,KAAKsF,IAAIlG,KAAKuG,KAAMC,EAAMD,OAMlCF,SAASG,GACL,OAAIA,EAAMF,KAAOtG,KAAKsG,KAAOE,EAAMD,MAAQvG,KAAKuG,KACrC,GACAC,EAAMF,IAAMtG,KAAKsG,KAAOE,EAAMD,KAAOvG,KAAKuG,KAC1C,CACH,IAAIH,EAASpG,KAAKsG,IAAKE,EAAMF,IAAM,GACnC,IAAIF,EAASI,EAAMD,KAAO,EAAGvG,KAAKuG,OAE/BC,EAAMF,KAAOtG,KAAKsG,IAClB,CAAC,IAAIF,EAASI,EAAMD,KAAO,EAAGvG,KAAKuG,OAEnC,CAAC,IAAIH,EAASpG,KAAKsG,IAAKE,EAAMF,IAAM,IAInDD,WACI,OAAOrG,KAAKsG,KAAOtG,KAAKuG,KACpBvG,KAAKsG,IAAIG,WAAazG,KAAKsG,IAAM,IAAMtG,KAAKuG,MAKxD,MAAMG,EACFL,YAAYM,EAAGzD,GACXlD,KAAK4G,OAAS,GACd5G,KAAKsF,OAAS,EACL,MAALqB,GAAW3G,KAAK6G,IAAIF,EAAGzD,GAG/BmD,iBACIrG,KAAKsF,OAAStF,KAAK4G,OAAOE,OAAO,CAACC,EAAUP,IACjCO,EAAWP,EAAMlB,OACzB,GAGPe,IAAIM,EAAGzD,GACH,IAAI8D,EAAQC,IAER,IADA,IAAIpC,EAAI,EACDA,EAAI7E,KAAK4G,OAAOtB,SAAW2B,EAASC,QAAQlH,KAAK4G,OAAO/B,KAC3DA,IAGJ,IADA,IAAIsC,EAAYnH,KAAK4G,OAAOlB,MAAM,EAAGb,GAC9BA,EAAI7E,KAAK4G,OAAOtB,QAAU2B,EAASC,QAAQlH,KAAK4G,OAAO/B,KAC1DoC,EAAWA,EAASJ,IAAI7G,KAAK4G,OAAO/B,IACpCA,IAEJsC,EAAU9C,KAAK4C,GACfjH,KAAK4G,OAASO,EAAUjF,OAAOlC,KAAK4G,OAAOlB,MAAMb,IACjD7E,KAAKoH,kBAST,OANIT,aAAaD,EACbC,EAAEC,OAAOtG,QAAQ0G,IAER,MAAL9D,IAAWA,EAAIyD,GACnBK,EAAK,IAAIZ,EAASO,EAAGzD,KAElBlD,KAGXqG,SAASM,EAAGzD,GACR,IAAImE,EAAaJ,IAEb,IADA,IAAIpC,EAAI,EACDA,EAAI7E,KAAK4G,OAAOtB,SAAW2B,EAASK,SAAStH,KAAK4G,OAAO/B,KAC5DA,IAGJ,IADA,IAAIsC,EAAYnH,KAAK4G,OAAOlB,MAAM,EAAGb,GAC9BA,EAAI7E,KAAK4G,OAAOtB,QAAU2B,EAASK,SAAStH,KAAK4G,OAAO/B,KAC3DsC,EAAYA,EAAUjF,OAAOlC,KAAK4G,OAAO/B,GAAG0C,SAASN,IACrDpC,IAEJ7E,KAAK4G,OAASO,EAAUjF,OAAOlC,KAAK4G,OAAOlB,MAAMb,IACjD7E,KAAKoH,kBAST,OANIT,aAAaD,EACbC,EAAEC,OAAOtG,QAAQ+G,IAER,MAALnE,IAAWA,EAAIyD,GACnBU,EAAU,IAAIjB,EAASO,EAAGzD,KAEvBlD,KAGXqG,UAAUM,EAAGzD,GACT,IAAIiE,EAAY,GACZK,EAAcP,IAEd,IADA,IAAIpC,EAAI,EACDA,EAAI7E,KAAK4G,OAAOtB,SAAW2B,EAASK,SAAStH,KAAK4G,OAAO/B,KAC5DA,IAEJ,KAAOA,EAAI7E,KAAK4G,OAAOtB,QAAU2B,EAASK,SAAStH,KAAK4G,OAAO/B,KAAK,CAChE,IAAIyB,EAAM1F,KAAKsF,IAAIlG,KAAK4G,OAAO/B,GAAGyB,IAAKW,EAASX,KAC5CC,EAAO3F,KAAKqF,IAAIjG,KAAK4G,OAAO/B,GAAG0B,KAAMU,EAASV,MAClDY,EAAU9C,KAAK,IAAI+B,EAASE,EAAKC,IACjC1B,MAYR,OARI8B,aAAaD,EACbC,EAAEC,OAAOtG,QAAQkH,IAER,MAALtE,IAAWA,EAAIyD,GACnBa,EAAW,IAAIpB,EAASO,EAAGzD,KAE/BlD,KAAK4G,OAASO,EACdnH,KAAKoH,iBACEpH,KAGXqG,MAAMoB,GAEF,IADA,IAAI5C,EAAI,EACDA,EAAI7E,KAAK4G,OAAOtB,QAAUtF,KAAK4G,OAAO/B,GAAGS,QAAUmC,GACtDA,GAASzH,KAAK4G,OAAO/B,GAAGS,OACxBT,IAEJ,OAAO7E,KAAK4G,OAAO/B,GAAGyB,IAAMmB,EAGhCpB,WACI,MAAO,KAAOrG,KAAK4G,OAAOc,KAAK,MAAQ,KAG3CrB,QACI,OAAO,IAAIK,EAAO1G,OAI1B,MAAiB0G,EC5JjB,MAAM7E,UFuRiBA,EEpRvB,MAAiB,MAAM8F,EAMrBtB,YAAYlC,EAAQyD,GAElB,GADA5H,KAAK6H,aAAa1D,GACdA,aAAkB2D,OACpB9H,KAAK+H,WAAa5D,EAAO4D,WACzB/H,KAAKgI,UAAY7D,EAAO6D,UACxB7D,EAASA,EAAO8D,WAEX,CAAA,GAAsB,iBAAX9D,EAIhB,MAAM,IAAI+D,MAAM,+BAHhBlI,KAAK+H,WAAaH,IAAyB,IAApBA,EAAEjE,QAAQ,KACjC3D,KAAKgI,UAAYJ,IAAyB,IAApBA,EAAEjE,QAAQ,KAKlC3D,KAAKkE,OAASiE,EAAIhE,GAUpBkC,aAAalC,GAIXnE,KAAKkG,IAAoB,MAAd/B,EAAO+B,IAAc/B,EAAO+B,IACZ,MAAzByB,EAAQS,UAAUlC,IAAcyB,EAAQS,UAAUlC,IAAM,IAI1DlG,KAAKqI,aAAelE,EAAOkE,aACzBlE,EAAOkE,aAAerI,KAAKqI,aAAaC,QAEtCnE,EAAOoE,UACTvI,KAAKuI,QAAUpE,EAAOoE,SAU1BlC,MACE,OAAOrG,KAAKwI,KAAKxI,KAAKkE,OAAQ,IAWhCmC,KAAKoC,EAAOC,GACV,IAAI3D,EAAOhC,EAAKL,EAAGmC,EAAGD,EAEtB,OAAQ6D,EAAM7G,MACZ,KAAKC,EAAMV,KACX,KAAKU,EAAMT,MAET,GAAIqH,EAAM5C,YAAc4C,EAAM3C,cAAiB,MAAO,GAWtD,IARI2C,EAAM7C,eAAkC+C,IAAtBF,EAAMG,cAC1BH,EAAMG,YAAcF,EAAOrE,KAAK,MAAQ,GAM1CtB,EAAM,GACD8B,EAAI,EAAGD,GAJZG,EAAQ0D,EAAMzC,QACZhG,KAAK6I,YAAYJ,EAAMzC,SAAWyC,EAAM1D,OAGpBO,OAAQT,EAAID,EAAGC,IACnC9B,GAAO/C,KAAKwI,KAAKzD,EAAMF,GAAI6D,GAM7B,OAHID,EAAM7C,WACR8C,EAAOD,EAAMG,aAAe7F,GAEvBA,EAET,KAAKlB,EAAMR,SAET,MAAO,GAET,KAAKQ,EAAMP,IACT,IAAIwH,EAAc9I,KAAK+I,QAAQN,GAC/B,OAAKK,EAAYxD,OACVzB,OAAOC,aAAa9D,KAAK6I,YAAYC,IADV,GAGpC,KAAKjH,EAAML,WAMT,IAJAkB,EAAI1C,KAAKuI,QAAQE,EAAMxC,IACrBwC,EAAMvC,MAAQC,EAAAA,EAAWsC,EAAMxC,IAAMjG,KAAKkG,IAAMuC,EAAMvC,KAExDnD,EAAM,GACD8B,EAAI,EAAGA,EAAInC,EAAGmC,IACjB9B,GAAO/C,KAAKwI,KAAKC,EAAMxG,MAAOyG,GAGhC,OAAO3F,EAET,KAAKlB,EAAMJ,UACT,OAAOiH,EAAOD,EAAMxG,MAAQ,IAAM,GAEpC,KAAKJ,EAAMH,KACT,IAAI+B,EAAOzD,KAAK+H,YAAc/H,KAAKgJ,YACjChJ,KAAKiJ,aAAaR,EAAMxG,OAASwG,EAAMxG,MACzC,OAAO4B,OAAOC,aAAaL,IAYjC4C,aAAa5C,GACX,OAAOA,GAAQ,IAAMA,GAAQA,GAAQ,KAAO,GAC1C,IAAMA,GAAQA,GAAQ,GAAO,GAAK,GAStC4C,YACE,OAAQrG,KAAKuI,QAAQ,EAAG,GAU1BlC,YAAY6C,GACV,OAAIA,aAAexC,EACVwC,EAAIzB,MAAMzH,KAAKuI,QAAQ,EAAGW,EAAI5D,OAAS,IAEzC4D,EAAIlJ,KAAKuI,QAAQ,EAAGW,EAAI5D,OAAS,IAW1Ce,QAAQoC,GACN,GAAIA,EAAM7G,OAASuG,EAAItG,MAAMH,KAC3B,OAAO,IAAIgF,EAAO+B,EAAMxG,OACnB,GAAIwG,EAAM7G,OAASuG,EAAItG,MAAMN,MAClC,OAAO,IAAImF,EAAO+B,EAAM3G,KAAM2G,EAAM1G,IAC/B,CACL,IAAIoH,EAAS,IAAIzC,EACjB,IAAK,IAAI7B,EAAI,EAAGA,EAAI4D,EAAMpG,IAAIiD,OAAQT,IAAK,CACzC,IAAIoC,EAAWjH,KAAK+I,QAAQN,EAAMpG,IAAIwC,IAEtC,GADAsE,EAAOtC,IAAII,GACPjH,KAAK+H,WACP,IAAK,IAAIqB,EAAI,EAAGA,EAAInC,EAAS3B,OAAQ8D,IAAK,CACxC,IAAI3F,EAAOwD,EAASQ,MAAM2B,GACtBC,EAAgBrJ,KAAKiJ,aAAaxF,GAClCA,IAAS4F,GACXF,EAAOtC,IAAIwC,IAKnB,OAAIZ,EAAMnG,IACDtC,KAAKqI,aAAaC,QAAQf,SAAS4B,GAEnCnJ,KAAKqI,aAAaC,QAAQgB,UAAUH,IAajD9C,QAAQM,EAAGzD,GACT,OAAOyD,EAAI/F,KAAK2I,MAAM3I,KAAKD,UAAY,EAAIuC,EAAIyD,IAOjD0B,mBACE,OAAOrI,KAAKwJ,OAASxJ,KAAKwJ,QAAU,IAAI9C,EAAO,GAAI,KAGrD2B,iBAAiB7B,GACfxG,KAAKwJ,OAAShD,EAYhBH,eAAelC,EAAQyD,GACrB,IAAI6B,EAYJ,MAXqB,iBAAXtF,IACRA,EAAS,IAAI2D,OAAO3D,EAAQyD,SAGNe,IAApBxE,EAAOuF,UACTD,EAAU,IAAI9B,EAAQxD,EAAQyD,GAC9BzD,EAAOuF,SAAWD,IAElBA,EAAUtF,EAAOuF,UACT7B,aAAa1D,GAEhBsF,EAAQE,MAOjBtD,eAEEyB,OAAOM,UAAUuB,IAAM,WACrB,OAAOhC,EAAQ8B,QAAQzJ,SClL7B,SAAS4J,EAAO3D,EAAKC,EAAK2D,EAAQC,EAAQC,0BAAe,GACvDF,OAA2B,IAAXA,EAAyBG,EAAIC,WAAaJ,EAC1DC,OAA2B,IAAXA,EAAyBE,EAAIE,WAAaJ,GAG1D5D,OAAqB,IAARA,EAAsB4D,EAAS5D,IAD5CD,OAAqB,IAARA,EAAsB4D,EAAS5D,KAI1CC,GAAOD,GAGL8D,EAzBN,SAAmB9D,EAAKC,UACdnF,EAAU,SAAVA,IAAyBmF,EAAMD,GAAQA,EAyBtCkE,CAAUlE,EAAKC,GAtF1B,SAA0BD,EAAKC,UAC7BD,OAAqB,IAARA,EAAsB+D,EAAII,YAAcnE,EACrDC,OAAqB,IAARA,EAAsB8D,EAAIK,YAAcnE,EAE9CtF,KAAK2I,MAAMxI,EAAU,SAAVA,IAA0BmF,EAAMD,EAAO,IAAMA,EAqFxDqE,CAAiBrE,EAAKC,SA2ChB,MA3Gf,SAAcqE,UACLA,EAAW3J,KAAK2I,MAAMxI,EAAU,SAAVA,GAAwBwJ,EAAWjF,eA6FlE,SAAckF,MACRA,SA5BN,SAAY5I,UACFA,OACD,iBACoB,GAAhBgI,EAAO,EAAG,QAEd,iBACqB,IAAjBA,EAAO,GAAI,QAEf,eACqB,MAAjBA,EAAO,GAAI,QAEf,cACoB,SAAhBA,EAAO,EAAG,QAEd,eACoB,UAAhBA,EAAO,EAAG,QAEd,gBACoB,WAAhBA,EAAO,EAAG,QAEd,eACoB,YAAhBA,EAAO,EAAG,KAQZa,CAAGD,OAGNE,EAAM,IAAIC,KACVC,EAAOhB,GAAQ,IAAMI,EAAIa,2BAE/BH,EAAII,QAAQJ,EAAIK,UAAYH,GAErBF,WA9FT,SAAiBH,WACXS,EACAC,EACA3F,EAASiF,EAAWjF,OAElB4F,EAAOX,EAAW7E,QAEjBJ,EAAS,GACd2F,EAAMrK,KAAK2I,MAAMxI,EAAU,SAAVA,GAAwBuE,GAGzC0F,EAAME,EADN5F,GAAU,GAEV4F,EAAK5F,GAAU4F,EAAKD,GACpBC,EAAKD,GAAOD,SAGPE,UAqFPtB,EACAH,QAlIF,SAAkBxH,UAEhB0F,EAAQS,UAAUlC,IAAMnF,EAAU,qBAGlC4G,EAAQS,UAAUG,iBAAW5B,EAAGzD,UAAMyD,EAAI/F,KAAK2I,MAAMxI,EAAU,SAAVA,IAA8BmC,EAAIyD,EAAT,KAEnE,IAAIgB,EAAQ1F,GAEb0H,QCuJZ,SAASwB,EAAMxE,EAAGzD,UAChBkI,OAAO/K,KAAK6C,GAAG5C,iBAAQ2K,GACC,iBAAX/H,EAAE+H,IAAgC,OAAX/H,EAAE+H,GAClCtE,EAAEsE,GAAO/H,EAAE+H,GACFI,MAAMC,QAAQpI,EAAE+H,KACzBtE,EAAEsE,GAAOtE,EAAEsE,IAAQ,GAEnB/H,EAAE+H,GAAK3K,iBAAQ2B,IACkB,IAA3B0E,EAAEsE,GAAKtH,QAAQ1B,IACjB0E,EAAEsE,GAAK5G,KAAKpC,MAGW,iBAAX0E,EAAEsE,IAAgC,OAAXtE,EAAEsE,IAAiBI,MAAMC,QAAQ3E,EAAEsE,IAC1EtE,EAAEsE,GAAOE,EAAM,GAAIjI,EAAE+H,IAErBtE,EAAEsE,GAAOE,EAAMxE,EAAEsE,GAAM/H,EAAE+H,MAItBtE,EAyBT,SAAS4E,WACA5K,EAAO6K,KAAK,EACjB,GACA,EACA,MACC,EACDC,IACA7K,KAAK8K,GACLvF,EAAAA,OACAwC,EACA,GACA,GAEA/H,KAAKD,SACLC,KAAKD,SAAS8F,SAAS,IAAIkF,OAAO,WA4GvB,iBA9Uf,SAAyBC,EAAKC,WACtBC,EAAcD,EAAgBE,MAAM,KAEnCD,EAAYxG,QAAQ,KACnB0G,EAAOF,EAAYG,YAEpBL,EAAII,SAITJ,EAAMA,EAAII,UAELJ,iBAUT,SAAuBA,wEACdM,EAAWC,gBAAOlB,eACI,IAAbW,EAAIX,KACjB3F,OAAS,aAuRd,SAAmBsG,EAAKQ,OAChBlB,EAAO,UAEbE,OAAO/K,KAAKuL,GAAKtL,iBAAQ+L,IACG,IAAtBD,EAAMzI,QAAQ0I,KACZhB,MAAMC,QAAQM,EAAIS,IACpBnB,EAAKmB,GAAKT,EAAIS,GAAG3G,QAEjBwF,EAAKmB,GAAKT,EAAIS,aAAcjB,OACxBD,EAAM,GAAIS,EAAIS,IACdT,EAAIS,MAKPnB,YAzRT,SAAkBtJ,EAAM0K,EAAQpM,OACxBqM,EAAS,UAGP3K,GAAQ0K,EAAO1K,UAChB,cACA,iBAC2B,IAAnB0K,EAAOE,UAChBD,EAAOC,QAAUF,EAAOE,cAGI,IAAnBF,EAAOG,UAChBF,EAAOE,QAAUH,EAAOG,SAGtBH,EAAOI,KAAM,KACXzG,EAAMrF,KAAKsF,IAAIqG,EAAOC,SAAW,EAAG,GACpCtG,EAAMtF,KAAKqF,IAAIsG,EAAOE,SAAWtG,EAAAA,EAAUA,EAAAA,GAE3CmG,EAAOK,kBAAoB1G,IAAQqG,EAAOE,UAC5CvG,GAAOqG,EAAOM,YAAc,GAG1BN,EAAOO,kBAAoB3G,IAAQoG,EAAOG,UAC5CvG,GAAOoG,EAAOM,YAAc,IAI1B3G,GAAOC,IAAQC,EAAAA,KACjBmG,EAAOI,KAAOJ,EAAOI,KAAKP,gBAAOW,UAC3BA,GAAK7G,GAAO6G,GAAK5G,eAWxB,cAC6B,IAArBoG,EAAOS,YAChBR,EAAOQ,UAAYT,EAAOS,gBAGI,IAArBT,EAAOU,YAChBT,EAAOS,UAAYV,EAAOU,eAGtBC,EAAalM,EAAU,aACvBmM,EAAanM,EAAU,aAGzBkM,GAAcV,EAAOS,UAAYC,IACnCV,EAAOS,UAAYC,GAIjBC,GAAcX,EAAOQ,UAAYG,IACnCX,EAAOQ,UAAYG,OAUrBjL,EAAQ/B,EAASqM,UAGb3K,GAAQ0K,EAAO1K,UAChB,SACHK,EAAQkL,WAAWlL,aAGhB,UACHA,EAAQyB,SAASzB,EAAO,cAGrB,UACHA,IAAUA,YAGP,SACHA,EAAQ4B,OAAO5B,WAETgE,EAAMrF,KAAKsF,IAAIqG,EAAOQ,WAAa,EAAG,GACtC7G,EAAMtF,KAAKqF,IAAIsG,EAAOS,WAAa7G,EAAAA,EAAUA,EAAAA,GAE5ClE,EAAMqD,OAASW,GACfqG,EAAOc,QAGVnL,GAAStB,EAAO8I,QAAQ6C,EAAOc,SAF/BnL,GAAU,GAAEtB,EAAO6K,KAAK,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,MAAQvJ,SAMpEA,EAAMqD,OAASY,IACjBjE,EAAQA,EAAM0J,OAAO,EAAGzF,IAGlBoG,EAAOe,YACR,gBACA,WACHpL,EAAQ,IAAI0I,KAAK1I,GAAOqL,cAActK,QAAQ,cAAe,iBAG1D,OACHf,EAAQ,IAAI0I,KAAK1I,GAAOqL,cAAc3B,OAAO,EAAG,cAG7C,OACH1J,EAAQ,IAAI0I,mBAAmB1I,GAASqL,cAAc3B,OAAO,YAY9D1J,SA8KPkJ,QArJF,SAAS7C,EAAMsD,UACRA,GAAsB,iBAARA,EAIfP,MAAMC,QAAQM,GACTA,EAAI2B,aAAIT,UAAKxE,EAAMwE,KAGrB1B,OAAO/K,KAAKuL,GAAK9E,gBAAQ0G,EAAMC,UACpCD,EAAKC,GAAOnF,EAAMsD,EAAI6B,IACfD,GACN,IAVM5B,SAaX,SAAeU,OACPrJ,EAAIyK,KAAKC,UAAUrB,GACnB1H,EAAI8I,KAAKC,UAAUrB,EAAQ,KAAM,UAEhCrJ,EAAEqC,OAAS,IAASV,EAAE+G,OAAO,EAAG,WAAY/G,YAqBrD,SAAkB0H,EAAQsB,OAClB1C,EAAOC,EAAM,GAAIyC,WAEO,IAAnBtB,EAAOE,UAChBtB,EAAKuB,QAAUH,EAAOE,QACtBtB,EAAK2B,kBAAmB,QAGI,IAAnBP,EAAOG,UAChBvB,EAAKsB,QAAUF,EAAOG,QAAUvB,EAAKuB,QAAU,EAAIH,EAAOG,QAC1DvB,EAAKyB,kBAAmB,QAGM,IAArBL,EAAOS,YAChB7B,EAAK8B,UAAYV,EAAOS,gBAGM,IAArBT,EAAOU,YAChB9B,EAAK6B,UAAYT,EAAOU,UAAY9B,EAAK8B,UAAY,EAAIV,EAAOU,WAG9DV,EAAO1K,KACTsJ,EAAKtJ,KAAOjB,EAAO6K,KAAKxB,EAAI6D,UAAU1B,gBAAOW,UAC7BzB,MAAMC,QAAQgB,EAAO1K,MAAQ0K,EAAO1K,KAAO,CAAC0K,EAAO1K,OAEpDkM,eAAMlM,SAEP,WAANkL,GAAwB,YAANA,EACJ,WAATlL,GAA8B,YAATA,EAGvBkL,IAAMlL,YAGZ,GAAI0K,EAAOI,KAAM,KAClBzK,KAGFA,EAAQsJ,WAC+B,IAAhCe,EAAOI,KAAK/I,QAAQ1B,IAE7BiJ,EAAKwB,KAAO,CAACzK,UAGXqK,EAAOyB,UAAY7C,EAAKgB,YAC1BI,EAAOyB,SAASzN,iBAAQ0L,UACfd,EAAKgB,WAAWF,KAMpBd,YA6DPK,WAzDF,SAAkBtJ,EAAO+L,UACfA,EAAQF,eAAMhB,eACK,IAAdA,EAAEN,SAA2BvK,GAAS6K,EAAEN,cAI1B,IAAdM,EAAEL,SAA2BxK,GAAS6K,EAAEL,iBAQvD,SAAeT,UACiF,IAAvF,CAAC,OAAQ,QAAS,UAAW,WAAY,WAAY,eAAerI,QAAQqI,aAqBrF,SAASiC,EAAShM,EAAOqK,UACnBjB,MAAMC,QAAQrJ,GACTA,EAAMsL,aAAIT,UAAKmB,EAASnB,EAAGR,MAGf,iBAAVrK,IACTA,EAAQA,EAAMe,QAAQ,2BAAoBkL,EAAGC,UAAO7B,EAAO6B,MAGtDlM,KCnRT,IAAMmM,EACJxO,gBAGOiB,SAAW,QACXwN,QAAU,IAOjBC,YAAAA,eAAMvO,GACCA,UAIIC,KAAKa,SAASd,UACdC,KAAKqO,QAAQtO,UAJfc,SAAW,QACXwN,QAAU,KAYnBE,YAAAA,gBAAOxO,EAAMG,OApFAyJ,cAqFN9I,SAASd,GAAQG,EAASF,KAAKa,SAASd,IAGxCC,KAAKqO,QAAQtO,UACXsO,QAAQtO,IAzFJ4J,oBAyFwB3J,EAAKa,SAASd,aAxF3CkC,EAAOqK,EAAQkC,EAAUC,OAC3BC,EAAKzM,EACL0M,EAAO,GAGU,iBAAV1M,IACTyM,EAAKtD,OAAO/K,KAAK4B,GAAO,GAGpBoJ,MAAMC,QAAQrJ,EAAMyM,IAEtBC,EAAO1M,EAAMyM,GAEbC,EAAKtK,KAAKpC,EAAMyM,aAKdtC,EAAQsC,EAAG3C,MAAM,KAGnB6C,EAAMjF,IAEHyC,EAAM9G,OAAS,GACpBsJ,EAAMA,EAAIxC,EAAMH,eAOG,mBAHrBhK,EAAuB,iBAAR2M,EAAmBA,EAAIxC,EAAM,IAAMwC,KAIhD3M,EAAQA,EAAM4M,MAAMD,EAAKD,EAAKpB,aAAIT,UAAK1H,EAAK6I,SAASnB,EAAG2B,OAIZ,oBAA1CrD,OAAOhD,UAAU3B,SAASqI,KAAK7M,IACjCmJ,OAAO/K,KAAK4B,GAAO3B,iBAAQ2K,MACC,mBAAfhJ,EAAMgJ,SACT,IAAI/C,mCAAmCsG,OAAaE,eAAezM,KAKxEA,MAqDT8M,YAAAA,gBAAOhP,EAAMG,QACNmO,QAAQtO,GAAQG,GAQvBK,YAAAA,aAAIR,WACiC,IAAxBC,KAAKa,SAASd,SACjB,IAAIiP,mBAAmBjP,wCAExBC,KAAKa,SAASd,IAOvBkP,YAAAA,cAAK3C,kBACGjM,EAAO+K,OAAO/K,KAAKiM,GACnB4C,EAAU,GAEZ5J,EAASjF,EAAKiF,wBAGVoJ,EAAKrO,EAAKiF,GAAQtC,QAAQ,MAAO,IACjC2G,EAAM3J,EAAKqO,QAAQK,MAEN,mBAAR/E,SACTyB,OAAO+D,eAAe7C,EAAQ,WAAY,eAC1B,cACF,YACF,iBACHmC,UAAc9E,EAAImF,KAAKI,EAAS5C,EAAOjM,EAAKiF,IAAUgH,EAAQjM,EAAKiF,GAASmJ,eATlFnJ,oCAeAgH,GC3IX7L,IAAMI,EAAW,IAAIlB,EAUrB,SAASyP,EAAUC,EAAiBnP,WACH,IAApBmP,SACFxO,EAASL,UAGa,iBAApB6O,KACe,mBAAbnP,EACTW,EAASZ,SAASoP,EAAiBnP,OAC9B,CAAA,GAAiB,OAAbA,IAAkC,IAAbA,SAGvBW,EAASN,IAAI8O,GAFpBxO,EAASf,WAAWuP,QAKtBxO,EAASV,aAAakP,GC3B1B,IAAMC,cACJ1P,WAAY2P,EAASC,gBAEftH,EAAMuH,mBACRvH,EAAMuH,kBAAkBzP,KAAMA,KAAKJ,kBAEhCG,KAAO,kBACPwP,QAAUA,OACVC,KAAOA,mGARStH,OCAnBwH,EAAqB,CACzBC,MAAO,CACL,kBACA,QACA,WACA,WACA,eAEFC,QAAS,CACP,mBACA,mBACA,UACA,UACA,cAEFC,OAAQ,CACN,uBACA,eACA,gBACA,gBACA,oBACA,aACA,YAEFC,OAAQ,CACN,YACA,YACA,UACA,WAIJJ,EAAmB9F,OAAS8F,EAAmBE,QAE/CnP,IAAMsP,EAAsB,CAC1B,kBACA,QACA,uBACA,eACA,oBACA,cAYF,SAASC,EAAYpE,EAAKqE,EAAmBC,UACpC9E,OAAO/K,KAAKuL,GAAKO,gBAAOH,OACvBmE,EAAcJ,EAAoBpM,QAAQsM,IAAsB,YACxCC,EAAuBvM,QAAQqI,IAAS,IAExCmE,KAK7B7K,OAAS,EC5Dd7E,IAAM2P,ECKN,kBACSrP,EAAU,SAAVA,GAAwB,ICNjCN,IAAM4P,ECGN,kBACS,MCHT,SAASC,EAAWrO,OACdgE,OAA+B,IAAlBhE,EAAMuK,QAA0BxC,EAAII,YAAcnI,EAAMuK,QACrEtG,OAA+B,IAAlBjE,EAAMwK,QAA0BzC,EAAIK,YAAcpI,EAAMwK,QAEnEG,EAAa3K,EAAM2K,cAErBA,IACF1G,EAAMtF,KAAK2I,MAAMrD,EAAM0G,GAAcA,EACrC3G,EAAMrF,KAAK2P,KAAKtK,EAAM2G,GAAcA,GAGlC3K,EAAM0K,kBAAoB1G,IAAQhE,EAAMuK,UAC1CvG,GAAO2G,GAAc,GAGnB3K,EAAM4K,kBAAoB3G,IAAQjE,EAAMwK,UAC1CvG,GAAO0G,GAAc,GAGnB3G,EAAMC,SACDuF,OAGLmB,EAAY,KAC2B,IAArC/I,OAAO+I,GAAYjJ,QAAQ,KAAa,SACtC6M,EAAO7P,EAAOiJ,OAAOhJ,KAAK2I,MAAMtD,EAAM2G,GAAahM,KAAK2I,MAAMrD,EAAM0G,IAAeA,EAEhF4D,EAAOvK,GACZuK,GAAQvO,EAAM2K,kBAGT4D,MAKLC,EACAC,EAHEC,GAAYzK,EAAMD,GAAO2G,KAO7B8D,GADAD,EAAM9P,EAAOiJ,OAAO,EAAG+G,GAAY/D,GACtBA,EAAc,QACZ,IAAR8D,UAIFD,SAGF9P,EAAOiJ,OAAO3D,EAAKC,OAAKyC,OAAWA,GAAW,GClDvDlI,IAAMmQ,EAAgB,6bAIb7E,MAAM,MAQf,SAAS8E,EAAevL,UACR3E,EAAOmQ,QAAQF,GAEhBlL,MAAM,EAAGJ,GCXxB7E,IAAMsQ,EAAU,CAAEnP,KAAM,CAAC,SAAU,SAAU,UAAW,YCExD,SAASoP,WAGAC,EAFQtQ,EAAOiJ,OAAO,EAAG,IAEXlC,KAAK,KAQ5B,SAASwJ,EAAejL,EAASC,kBAAH,kBAAS,aAC/BiL,EAAOvQ,KAAKsF,IAAI,EAAGD,GACnBmL,EAAOzQ,EAAOiJ,OAAOuH,EAAMjL,GAE7BmL,EAASL,IAGNK,EAAO/L,OAAS6L,GACrBE,GAAUL,WAIRK,EAAO/L,OAAS8L,IAClBC,EAASA,EAAO1F,OAAO,EAAGyF,IAGrBC,EC5BT,SAASC,WACA3Q,EAAO4Q,OAAOjE,cCNvB7M,IACM+Q,EAAe,kDAOfC,EAAU,CACdC,MAAO,sDACPC,SAAU,8BACVC,KAAM,+BACNC,IAAKL,EACLM,KAAM,iCAGcN,EAdA,wDAeJA,EAAYxO,QAAQ,MAAO,yDAjB5B,0BAkBkBA,QAAQ,KAAM,mBAG/C+O,KAAM,+DAGRN,EAAQO,IAAMP,EAAQ,iBACtBA,EAAQ,iBAAmBA,EAAQ,iBAEnCA,EAAQ,aAAeA,EAAQC,MAC/BD,EAAQ,gBAAkBA,EAAQE,SAElClR,IAAMwR,GAAkB,IAAInK,cAAcsD,OAAO/K,KAAKoR,GAAS/J,KAAK,aCrBpE,SAASwK,GAAejQ,EAAOkQ,OD6BFC,EC5BrBlS,EAAWmN,EAAOpL,EAAMoL,WAEN,mBAAbnN,SACFA,EAAS+B,UAGVA,EAAMoL,YACP,gBACA,kBACIgF,QACJ,cCdAf,IAAoB5L,MAAM,EAAG,QDgB7B,cEhBA4L,IAAoB5L,MAAM,QFkB1B,aGlBA,CAAC,EAAG,EAAG,EAAG,GAAG6H,sBACX5M,EAAOiJ,OAAO,EAAG,OACvBlC,KAAK,SHkBD,cAEI,UACJ,YACA,eACA,WACA,UACA,oBACA,UACA,oBACA,gBACA,mBACA,mBACA,WACA,mBACA,cDHoB0K,ECILnQ,EAAMoL,ODHrB1M,EAAO8I,QAAQgI,EAAQW,IAAapP,QAAQiP,YAAkBK,EAAOrH,UACnEtK,EAAO8I,QAAQgI,EAAQxG,sBCIJ,IAAb/K,EAA0B,IAC/Ba,EAAU,6BACN,IAAImH,8BAA8BqK,EAAMC,MAAMvQ,EAAMoL,gBAEnD8E,UAIL,IAAIjK,6BAA6BjG,eI9C7CxB,IAAMgS,GAAU,CACdC,QAASC,EACTC,KAAMC,EACNlD,MC+BF,SAAmB1N,EAAOuN,EAAMsD,EAASC,OACjCC,EAAQ,OAER/Q,EAAM+Q,QAAS/Q,EAAMgR,gBAAkB,IACvCV,EAAMW,cAAcjR,EAAO,WAAY,WAAY,qBAC/C,IAAIqN,uBAAgCiD,EAAMC,MAAMvQ,GAAUuN,UAE3DwD,KAGL3H,MAAMC,QAAQrJ,EAAM+Q,cACf/Q,EAAM+Q,MAAMzF,aAAK4F,EAAMlI,OACtBmI,EAAc5D,EAAKtN,OAAO,CAAC,QAAS+I,WAEnC8H,EAAiBI,EAAMC,EAAaN,SAI3CO,EAAWpR,EAAMoR,SACjBC,EAAWrR,EAAMqR,SAEjBvS,EAAU,cAEZsS,EAAYC,EAER1S,KAAKqF,IAAIlF,EAAU,YAAauS,GADhCvS,EAAU,aAIZA,EAAU,cAERuS,GAAYA,EAAWvS,EAAU,cACnCuS,EAAWvS,EAAU,aAInBsS,GAAYA,EAAWtS,EAAU,cACnCsS,EAAWC,QAITC,GAA4D,IAArCxS,EAAU,uBAAkC,EAAMA,EAAU,wBACnFyS,EAAqBzS,EAAU,wBAA0BA,EAAU,wBAAyB,EAE9FuE,EAAS3E,EAAOiJ,OAAOyJ,EAAUC,EAAU,EAAG,IAErB,IAAzBC,IACFjO,EAAS1E,KAAKsF,IAAIsN,EACd5S,KAAK6S,OAAOH,GAAYhO,GAAUiO,GAClC3S,KAAK8S,IAAI/S,EAAOiJ,OAAOyJ,EAAUC,GAAYC,GAAuBF,GAAY,YAIhFM,EAA0C,iBAA1B1R,EAAMgR,gBAA+BhR,EAAMgR,gBAAkB,GAE1EW,EAAUZ,EAAM1N,OAAQsO,EAAUtO,EAAQsO,GAAW,EAAG,KACzDR,EAAc5D,EAAKtN,OAAO,CAAC,QAAS0R,IACpCC,EAAUd,EAAiB9Q,EAAM+Q,OAASW,EAAQP,EAAaN,GAErEE,EAAM3O,KAAKwP,UAGT5R,EAAM6R,YAjGZ,SAAgBtE,EAAMwD,EAAO/Q,EAAO0R,EAAQb,EAASC,OAC7C/H,EAAM,GACN+I,EAAO,YAEJC,EAAKpI,OACNqI,EAAOvG,KAAKC,UAAU/B,UAEA,IAAxBmI,EAAKpQ,QAAQsQ,KACfF,EAAK1P,KAAK4P,GACVjJ,EAAI3G,KAAKuH,IAEF,GAMXoH,EAAM1S,QAAQ0T,WAGVE,EAAQ,IAELlJ,EAAI1F,SAAW0N,EAAM1N,SACrB0O,EAAKjB,EAAiB9Q,EAAM+Q,OAASW,EAAQnE,EAAMsD,MACtDoB,GAAS,GAGNA,YAKAlJ,EAkEEmJ,CAAO3E,EAAKtN,OAAO,CAAC,UAAW8Q,EAAO/Q,EAAO0R,EAAQb,EAASC,GAGhEC,GD/FPpD,QENF,SAAqB3N,UACZ2H,iBAASgD,WAAY,GAAM3K,KFMlC2H,OAAQwK,EACRvE,ORLF,SAAoB5N,EAAOuN,EAAMsD,EAASC,OAClC3G,EAAQ,GAERF,EAAajK,EAAMiK,YAAc,GACjCmI,EAAoBpS,EAAMoS,mBAAqB,GAC/CC,EAA+C,kBAAnBrS,EAAM8L,SAAyB,IAAM9L,EAAM8L,UAAY,IAAIrI,QACvF6O,GAAkD,IAA/BtS,EAAMuS,qBAEzBC,EAAerJ,OAAO/K,KAAK6L,GAC3BwI,EAAsBtJ,OAAO/K,KAAKgU,GAClCM,EAAqBF,EAAavS,OAAOwS,GAAqB5N,gBAAQ8N,EAAWC,UAC3C,IAAtCP,EAAmB3Q,QAAQkR,IAAcD,EAAUvQ,KAAKwQ,GACrDD,GACN,IACGE,EAAgBR,EAAmBpS,OAAOyS,GAE1CH,EAAuBD,IACO,IAA/BtS,EAAMuS,qBAAgCzD,EACvC9O,EAAMuS,yBAELD,GACwB,IAAxBE,EAAanP,QACkB,IAA/BoP,EAAoBpP,QACpBiN,EAAMW,cAAcjR,EAAO,gBAAiB,gBAAiB,eAAgB,kBAGzE,OAGyB,IAA9BlB,EAAU,uBACZuT,EAAmBhU,iBAAQ2K,GACrBiB,EAAWjB,KACbmB,EAAMnB,GAAOiB,EAAWjB,MAIrB8H,EAAiB3G,EAAOoD,EAAKtN,OAAO,CAAC,eAAgB4Q,OAGxDS,GAA4D,IAArCxS,EAAU,uBAAkC,EAAMA,EAAU,wBACnFyS,EAAqBzS,EAAU,wBAA0BA,EAAU,wBAAyB,EAC5FgU,EAAmBhU,EAAU,qBAAuB,GAEpDkF,EAAMrF,KAAKsF,IAAIjE,EAAM+S,eAAiB,EAAGV,EAAmBhP,QAC5DY,EAAMjE,EAAMgT,eAAkBH,EAAcxP,OAAS3E,EAAOiJ,OAAO,EAAG,GAExEsL,EAAetU,KAAKsF,IAAI,EAAGD,EAAMqO,EAAmBhP,QAE3B,IAAzBwP,EAAcxP,QAAiBgP,EAAmBhP,SACpD4P,EAAevU,EAAOiJ,OAAOsL,EAAcJ,EAAcxP,QAAUwP,EAAcxP,OAASW,MAG/D,IAAzBsN,IAEA2B,GADyB,IAAvB1B,EACa5S,KAAK6S,MAAOxN,EAAMqO,EAAmBhP,OAAWiO,GAAwBuB,EAAcxP,OAASW,IAE/FtF,EAAOiJ,OAAO3D,EAAMqO,EAAmBhP,OAAQiO,GAAwBuB,EAAcxP,OAASW,SAI3GkP,EAA6BxU,EAAOmQ,QAAQ6D,GAAoBjP,MAAM,EAAGwP,GACzEE,EAAkBT,EAAmBxI,gBAAOkJ,UACM,IAA/CF,EAA2BxR,QAAQ0R,KAItCC,EAAShB,EAAmBpS,OAAOkT,GAAiB1P,MAAM,EAAGQ,GAC7DqP,EAAS,MAEXtT,EAAMuT,eACRpK,OAAO/K,KAAK4B,EAAMuT,cAAclV,iBAAQ0L,OAChCyJ,EAAYxT,EAAMuT,aAAaxJ,IAEP,IAA1BsJ,EAAO3R,QAAQqI,KACbX,MAAMC,QAAQmK,GAEhBA,EAAUnV,iBAAQoV,IACa,IAAzBJ,EAAO3R,QAAQ+R,IACjBJ,EAAOjR,KAAKqR,KAIhBH,EAAOlR,KAAKoR,MAMdF,EAAOjQ,sBACFrD,EAAMuT,aAENzC,EAAiB,CACtB4C,MAAOJ,EAAOrT,OAAOD,IACpBuN,EAAKtN,OAAO,CAAC,eAAgB4Q,OAI9B8C,EAAU,GAGhBN,EAAOhV,iBAAQ2K,OACR4K,IAAIhR,EAAI,EAAGA,EAAIkQ,EAAiBzP,OAAQT,GAAK,KAC3CkQ,EAAiBlQ,aAAciD,QAAUiN,EAAiBlQ,GAAGd,KAAKkH,IAClC,iBAAxB8J,EAAiBlQ,IAAmBkQ,EAAiBlQ,KAAOoG,GACpC,mBAAxB8J,EAAiBlQ,IAAqBkQ,EAAiBlQ,GAAGqH,EAAWjB,GAAMA,eACtF2K,EAAQvR,KAAK4G,OAab6K,MARyB,IAAzBtB,GACuC,IAArCF,EAAmB3Q,QAAQsH,KAC7BmB,EAAMnB,GAAOiB,EAAWjB,IAEjBiB,EAAWjB,KACpBmB,EAAMnB,GAAOiB,EAAWjB,IAM1ByJ,EAAoBpU,iBAAQuU,GACtB5J,EAAIqH,MAAM,IAAIxK,OAAO+M,MACvBiB,GAAQ,EAEJ1J,EAAMnB,GACRsH,EAAMpH,MAAMiB,EAAMnB,GAAMoJ,EAAkBQ,IAE1CzI,EAAMzL,EAAO8I,QAAQwB,IAAQoJ,EAAkBQ,OAKhDiB,EAAO,KAEJC,EAAY1B,EAAkBpJ,IAAQuJ,EAIxCuB,IAAsC,IAAzBvB,IAEfpI,EAAMiI,EAAkBpJ,GAAOtK,EAAO8I,QAAQwB,GAAOA,GAAOiB,EAAWjB,IAAQ8K,UAO/EC,EAAYjV,EAAU,kBACtBkV,EAAalV,EAAU,mBAGzB6S,EAAUxI,OAAO/K,KAAK+L,GAAO9G,QAAU0Q,EAAY,EAAIJ,EAAQtQ,QAG7D4Q,WAAOC,UAAUxV,EAAO8I,4BAA2B0M,EAAS,OAAS,eAElE5V,QACH6V,KAGFA,EAAM9B,EAAmBrI,cAClBG,EAAMgK,WAERA,OAGFJ,IACCtB,EAAoBpP,QAAUiP,MAIhCX,GAAW3N,IALC,IASZsO,KACE0B,GAAgBxB,EAAanP,OAASsO,EAAW3N,EAAM,KACrDoQ,EAAQ,EACRpL,WAED,KACDoL,GAAS,GAGG,UAIZpL,EAAM1K,KAASI,EAAO6K,KAAKiJ,cACE,IAAfrI,EAAMnB,SAEI,IAAfmB,EAAMnB,KACfmB,EAAMnB,GAAOiB,EAAWjB,GACxB2I,GAAW,QAER,GAAIc,EAAoBpP,SAAWkP,EAAsB,KACxDxI,EAAOrL,EAAO6K,KAAKkJ,GACnB4B,EAAO3V,EAAO8I,QAAQuC,GAEvBI,EAAMkK,KACTlK,EAAMkK,GAAQjC,EAAkBrI,GAChC4H,GAAW,OAER,KACC0C,EAAO/V,KAAU0Q,EAAM,GAAKiF,IAE7B9J,EAAMkK,KACTlK,EAAMkK,GAAQ9B,GAAwBzD,EACtC6C,GAAW,OAKZiC,IAAIhR,EAAI,EAAG+O,EAAU3N,GAAOpB,EAAI6P,EAAoBpP,OAAQT,GAAK,EAAG,KACjEgQ,EAAOH,EAAoB7P,GAC3ByR,EAAO3V,EAAO8I,QAAQoL,GAGvBzI,EAAMkK,KACTlK,EAAMkK,GAAQjC,EAAkBQ,GAChCjB,GAAW,YAMXnH,EAAU9L,EAAOiJ,OAAO3D,EAAKC,GAE5B0N,EAAUnH,GAAW+H,GAAuB,KAC3C8B,EAAOrF,EAAM,GAAKiF,GAAK,GAExB9J,EAAMkK,KACTlK,EAAMkK,GAAQ9B,EACdZ,GAAW,UAIRb,EAAiB3G,EAAOoD,EAAKtN,OAAO,CAAC,eAAgB4Q,IQxO5DhD,OJ2CF,SAAoB7N,UAEHsQ,EAAMgE,SAAS,SAAUtU,WAAOuU,UACzCvU,EAAMoL,OACD6E,GAAejQ,oBAAawU,EAAMD,EAAKzJ,UAAWyJ,EAAKxJ,aAG5D/K,EAAMmL,QACDzM,EAAO8I,QAAQxH,EAAMmL,SAGvBqJ,EAAMD,EAAKzJ,UAAWyJ,EAAKxJ,eO7DtC,SAAS0J,GAASpK,EAAQkD,EAAMsD,EAASrE,MACvCnC,EAASwG,EAAQxG,OAAQ3D,EAAW6G,OAON,eAA1BA,EAAKA,EAAKlK,OAAS,GAAqB,IAEtCvE,EAAU,qBAAuBsK,MAAMC,QAAQgB,EAAOqK,UAAW,KAE7DC,EAAgBtK,EAAOqK,SAC1BzU,OAAO,YAAaoK,EAAS,CAACA,EAAOuK,SAAW,WAE5CtE,EAAMgE,SAAS,KAAMjK,oBAAc3L,EAAO6K,KAAKoL,QAGpD7V,EAAU,oBAAsB,YAAauL,SACxCA,EAAOuK,WAGZ,aAAcvK,SACTiG,EAAMtE,SAAS3B,EAAO2B,SAAUQ,MAIvCnC,EAAOhK,KAA6B,iBAAfgK,EAAOhK,MAC9BgK,EAASiG,EAAMuE,SAASxK,EAAOhK,IAAKiQ,EAAMwE,UAAUzK,EAAQ,CAAC,UAG3D,UAAWA,SACNA,EAAO7L,SAGZ4K,MAAMC,QAAQgB,EAAOI,aAChB6F,EAAMgE,SAAS,KAAMjK,oBAAc3L,EAAO6K,KAAKc,EAAOI,WAInC,mBAAjBJ,EAAOmK,aACTC,GAASpK,EAAOmK,QAASjH,EAAMsD,MAGT,mBAApBxG,EAAO0K,gBACTzE,EAAMgE,SAAS,KAAMjK,oBAAcA,EAAO0K,SAASvI,SAIxD7M,EAAO0K,EAAO1K,QAEdyJ,MAAMC,QAAQ1J,GAChBA,EAAOjB,EAAO6K,KAAK5J,QACM,IAATA,IAEhBA,ElBQJ,SAAmBgK,EAAKqL,WAChB5W,EAAO+K,OAAO/K,KAAKqP,GAEhB7K,EAAI,EAAGA,EAAIxE,EAAKiF,OAAQT,GAAK,EAAG,KACjCqS,EAAW7W,EAAKwE,MAGlBmL,EAAYpE,EAFUqL,EAAWA,EAAW3R,OAAS,GAEjBoK,EAAmBwH,WAClDA,GkBhBFC,CAAU7K,EAAQkD,IAAS5N,KAGhC0K,EAAO1K,KAAOA,GAIE,iBAATA,EAAmB,KACvBC,GAAMD,GAAO,IACZb,EAAU,4BACN,IAAIuO,uBAAgCiD,EAAMC,MAAM5Q,GAAS4N,EAAKtN,OAAO,CAAC,iBAErEnB,EAAU,wCAIVc,GAAMD,GAAM0K,EAAQkD,EAAMsD,EAAS4D,IAC1C,MAAOU,WACe,IAAXA,EAAE5H,WACL,IAAIF,EAAW8H,EAAErS,MAAOyK,SAE1B4H,OAKRlM,EAAO,UAEPG,MAAMC,QAAQgB,KAChBpB,EAAO,IAGTE,OAAO/K,KAAKiM,GAAQhM,iBAAQ0L,GACE,iBAAjBM,EAAON,IAA+B,gBAATA,EACtCd,EAAKc,GAAQ0K,GAASpK,EAAON,GAAOwD,EAAKtN,OAAO,CAAC8J,IAAQ8G,EAAS5H,GAElEA,EAAKc,GAAQM,EAAON,KAIjBd,GCxET,SAAS4H,GAAQlH,EAAK/L,EAAMwX,EAAQ7I,OAC7B5C,GAAsB,iBAARA,SACVA,KAGJyL,IACHA,EAAS,IAGNxX,IACHA,EAAO+L,GAGLP,MAAMC,QAAQM,UACTA,EAAI2B,aAAIT,UAAKgG,GAAQhG,EAAGjN,EAAMwX,EAAQ7I,QAG3C5C,EAAI0L,SAAU,KACV/K,EAAiC,iBAAjBX,EAAI0L,SACtB,CAAE9H,KAAM5D,EAAI0L,UACZ1L,EAAI0L,SAER/K,EAAO5G,MAAQiG,EAAIjG,OAAS4G,EAAO5G,OAAS6I,EAC5CjC,EAAOgL,MAAQ3L,EAAI2L,OAAShL,EAAOgL,QAAS,EAC5ChL,EAAOiL,QAAU5L,EAAI4L,SAAWjL,EAAOiL,UAAW,EAClDjL,EAAO8J,MAAQzK,EAAIyK,OAAS9J,EAAO8J,OAAS,MAEtCpL,EAASsB,aAAiBA,EAAY,YAEvC8K,EAAOpM,KACNsB,EAAO8J,MAAQ,EACjBgB,EAAOpM,GAAOwM,WAASlL,EAAOiD,KAAM3P,GAAM6F,MAAM,EAAG6G,EAAO8J,OAE1DgB,EAAOpM,GAAOwM,WAASlL,EAAOiD,KAAM3P,IAIpC0M,EAAOgL,OAAShL,EAAOiL,QAvD/B,SAAe3X,EAAM2X,OACdnM,MAAMC,QAAQzL,UACVA,MAGHoC,EAAQuV,EACV3X,EAAKkG,MACLlG,EAAKoM,eAELuL,EACF3X,EAAK6X,QAAQzV,GAEbpC,EAAKwE,KAAKpC,GAGLA,EAyCIsV,CAAMF,EAAOpM,GAAMsB,EAAOiL,SA9DvC,SAAc3X,UACLwL,MAAMC,QAAQzL,GACjBc,EAAO6K,KAAK3L,GACZA,EA8DK2L,CAAK6L,EAAOpM,WAGrBG,OAAO/K,KAAKuL,GAAKtL,iBAAQ+L,GACvBT,EAAIS,GAAKyG,GAAQlH,EAAIS,GAAIxM,EAAMwX,EAAQhL,KAGlCT,EAIT,SAAS+L,GAAIC,EAAMtL,EAAQuL,WAEjBxG,EAASqF,GAASnE,EAAMjK,MAAMgE,GAAS,GAAI,SAASxF,EAAO4O,EAAKoC,EAAgBC,WACtD,IAAnBD,IACTA,EAAiBnX,EAAOiJ,OAAO,EAAG,KAG/B8L,SACI,QAGmB,mBAAjBA,EAAIsB,gBACNtB,KAMU,iBAFPA,EAAIsC,KAAOtC,EAAIuC,aAGlBvC,EAAIuC,UACJvC,EAAIsC,WACJtC,EAAIwC,SAGW,iBAAbxC,EAAIyC,KAAmB,IACf,MAAbzC,EAAIyC,mBACCzC,EAAIyC,KACJzC,MAGL0C,MAE4B,IAA5B1C,EAAIyC,KAAKxU,QAAQ,QACnByU,EAAMR,EAAKlC,EAAIyC,OAAS,MAGiB,IAAvCzC,EAAIyC,KAAKxU,QAAQ,oBACnByU,EAAM9L,EAAO+L,YAAY3C,EAAIyC,KAAKpM,MAAM,kBAAkB,KAAO,WAGhD,IAARqM,EAAqB,KACzBA,IAA0C,IAAnCrX,EAAU,2BACd,IAAImH,8BAA8BwN,EAAS,MAGnDnD,EAAMpH,MAAMuK,EAAK0C,GAAO,kBAInB1C,EAAIyC,KACJzC,KAGLrK,MAAMC,QAAQoK,EAAIC,OAAQ,KACtB3H,EAAU0H,EAAIC,aAEbD,EAAIC,MAIX3H,EAAQ1N,iBAAQgY,OACRC,EAAOzR,EAAOwR,EAAWR,EAAiB,EAAGC,GAGnDxF,EAAMpH,MAAMuK,EAA2B,mBAAf6C,EAAK9B,MACzB8B,EAAK9B,QACL8B,QAIJlN,MAAMC,QAAQoK,EAAI8C,OAAS9C,EAAI+C,OAAQ,KACnCC,EAAMhD,EAAI8C,OAAS9C,EAAI+C,aAIzB/C,EAAIhJ,MAAQgJ,EAAI8C,QAClB9C,EAAIhJ,KAAOgJ,EAAIhJ,KAAKP,gBAAOW,UAAKyF,EAAMoG,SAAS7L,EAAG4L,MAG7C,CACLjC,qBACQvL,EAAOqH,EAAMwE,UAAUrB,EAAK,CAAC,QAAS,UACtCkD,EAAQjY,EAAO6K,KAAKkN,UAC1BnG,EAAMpH,MAAMD,EAAM0N,GAEdlD,EAAI8C,OACNE,EAAIpY,iBAAQuY,GACNA,IAASD,GAASC,EAAK9K,UACzB8K,EAAK9K,SAASzN,iBAAQ2K,UACbC,EAAKgB,WAAWjB,OAMxBC,OAKbE,OAAO/K,KAAKqV,GAAKpV,iBAAQ0L,IAClBX,MAAMC,QAAQoK,EAAI1J,KAA+B,iBAAd0J,EAAI1J,IAAwBuG,EAAMuG,MAAM9M,KAC9E0J,EAAI1J,GAAQlF,EAAO4O,EAAI1J,GAAO8L,EAAgBC,EAAiB7V,OAAO8J,OAKtE+L,EAAkB,KACdgB,EAAWhB,EAAiBA,EAAiBzS,OAAS,MAE3C,eAAbyT,GAA0C,UAAbA,SACxBrD,SAIJmC,EAAU5I,KAAKyG,YAGpB3U,EAAU,mBACL+R,GAAQzB,GAGVA,EACP,MAAO+F,SACHA,EAAE5H,KACE,IAAItH,MAASkP,kBAAiBA,EAAE5H,KAAK9H,KAAK,MAE1C0P,GCxMZ3W,IAAMoX,GAAY,IAAIzJ,EAEtB,SAAS4K,KAEPnB,GAAU9I,OAAO,UAAWpO,EAAO8I,SAGnCoO,GAAU9I,OAAO,gBAAiB,SAAuB9M,EAAOqK,OACzDtM,KAAKiZ,OAAQ,KACVhT,EAAMqG,EAAOE,SAAW,EACxBtG,EAAMD,EAAM+D,EAAIE,WAChB+O,EAAShX,EAAMiX,eAAiB5M,EAAO4M,mBAExCD,OAASA,GAAUtY,EAAOiJ,OAAO3D,EAAKC,UAG/B,IAAVjE,EACKjC,KAAKiZ,SAGP3M,IAITuL,GAAU9I,OAAO,iBAAkB,SAAwB9M,EAAOqK,MAC3DtM,KAAK0K,WACHA,IAAM/J,EAAO4Q,QAGhBtP,EAAO,IACTqK,EAAStM,KAAK0K,IAAI4C,eAK0E,IAAxF,CAAC,UAAW,UAAW,QAAS,OAAQ,QAAS,SAAU,SAAS3J,QAJxE1B,GAAkB,IAAVA,EACJ,OACAA,SAGI,IAAIiG,kCAAkCqK,EAAMC,MAAMvQ,SAGrDyI,IAAII,QAAQ9K,KAAK0K,IAAIK,UAAYpK,EAAO4Q,KAAKtP,WAG7CqK,IAIX,SAAS6M,GAAQvB,OACXwB,EAAQ,UAER/N,MAAMC,QAAQsM,GAChBA,EAAKtX,iBAAQgM,GACX8M,EAAM9M,EAAO0L,KAAO1L,EAAO2L,IAAM3L,IAGnC8M,EAAQxB,GAAQ,GAGXwB,EAGT3Y,IAAM4Y,YAAO/M,EAAQsL,EAAM0B,UACzBC,QAAQC,IAAI,sGAERF,GACFC,QAAQC,IAAI,2EAGPH,GAAIrC,SAAS1K,EAAQsL,WAG9ByB,GAAIrC,kBAAY1K,EAAQsL,UAGfD,GAFOwB,GAAQvB,GAEJtL,EAAQuL,KAG5BwB,GAAIvG,iBAAWxG,EAAQsL,EAAM0B,GACP,iBAAT1B,IACT0B,EAAM1B,EACNA,EAAO,IAKT0B,GADAA,EAAMA,IAA2B,oBAAZG,QAA0BA,QAAQH,MAAQ,KAClDtW,QAAQ,OAAQ,YAEvBoW,EAAQD,GAAQvB,GAGhB8B,EAAY,CAChBC,MAAO,IACPC,SAAS,EACTC,cAAKC,EAAM5Z,OAEPA,EAAS,KAAMkZ,EAAMU,EAAKC,MAAQX,EAAMU,EAAKC,IAAIhO,MAAM,KAAKhG,QAC5D,MAAOqR,GACPlX,EAASkX,aAKR4C,EACJC,YAAYX,EAAKhN,EAAQ,CACxBwG,QAAS,CACPgH,KAAM,CAAEH,MAAO,KACfO,KAAM,CAAEP,MAAO,eACfD,GAEFO,YAAa,CACXE,SAAU,YAEXC,cAAK1E,UAAOiC,GAAIyB,EAAO1D,EAAKmC,OAGnCmB,KAEAK,GAAIhM,OAASA,EACbgM,GAAIgB,OAASA,EACbhB,GAAI1Y,OAASA,EAGb0Y,GAAI9K,gBAAUxO,EAAMua,UAClBzC,GAAUtJ,OAAOxO,EAAMua,GAChBjB,IAGTA,GAAItK,gBAAUhP,EAAMua,UAClBzC,GAAU9I,OAAOhP,EAAMua,GAChBjB,IAGTA,GAAI/K,eAAQvO,UACV8X,GAAUvJ,MAAMvO,GAChBiZ,KACOK,IAGTA,GAAIkB,gBAASxa,UACJ8X,GAAUtX,IAAIR,IAGvBsZ,GAAImB,QAAU"}